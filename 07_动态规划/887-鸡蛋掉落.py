"""
hard 2022-03-12 dp+二分
[二分]https://www.bilibili.com/video/BV1Tv411i7cP/?spm_id_from=333.788.recommend_more_video.-1
[01背包的思路，简单]https://leetcode-cn.com/problems/super-egg-drop/solution/01bei-bao-wen-ti-kan-dong-ji-dan-diao-lu-axp6/
题目：k个鸡蛋n层楼，确定楼层F，高于F，鸡蛋会碎；低于F，鸡蛋不会碎。求问需要操作多少次，才能确定F。
返回的是最小操作次数.

# 解法2
# “求k个鸡蛋在m步内可以测出多少层”。我们令dp[k][m]表示k个鸡蛋在m步内可以测出的最多的层数，那么当我们在第X层扔鸡蛋的时候，就有两种情况：

dp[i][j] 表示：容量（鸡蛋数）为i的背包，放入物品重量（操作数）为j时，价值(确定楼层)是多少。
当第i个鸡蛋、第count次扔出操作时，蛋要么碎，要么不碎，所能确定的楼层都+1
dp[i][count]：表示你还剩 i 个蛋，且已操作 count 次，所能确定的楼层。
dp[i][count-1]：当蛋没碎，情况为少1次操作数，所能确定的楼层
dp[i-1][count-1]：当蛋碎了，情况为少1个蛋，少1次操作数，所能确定的楼层
当前价值 = 鸡蛋碎了的价值 + 鸡蛋没碎的价值 + 确定当前层的价值1
# 是“本次扔之后可能测出来的层数 + 本次扔之前已经测出来的层数”
"""
class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        # dp[k][n]表示k个鸡蛋在n步内可以确定的最多的层数
        dp = [[0]*(n+1) for _ in range(k+1)]

        for m in range(1,n+1):
            dp[0][m]=0 # zero egg
            for i in range(1,k+1):
                # 本次扔之后可能测出来的层数（dp[k-1][m-1]+dp[k][m-1]） + 本次扔之前已经测出来的层数（1）
                dp[i][m]=dp[i-1][m-1]+dp[i][m-1]+1
                if dp[i][m]>=n:
                    return m
        return n
"""
解释一下最后一种解法中的递推公式是怎么来的。
dp[k][m] 表示用 k 个鸡蛋移动 m 步可以“保证求解”的最大楼层数。

我们先解释一下定义中的几个概念：
所谓“求解”，意思就是给定楼层 N，我们能否找到临界楼层 F(F <= N)，使得鸡蛋从 F 层掉落刚好不会被摔碎。所谓“保证求解”，意思就是即使每次丢鸡蛋的结果都很差，最终仍能求解。
比如，给定 1 个鸡蛋移动 1 步，那么可以求解的最大楼层数为 1，即从 1 楼丢下，如果鸡蛋碎了，求得 F=0，如果鸡蛋没碎，求得 F=1。
在这种情况下，假如我们给出一个 2 层的楼，就无法保证求解了，因为无论从哪一层丢出鸡蛋，都没有十足的把握能够一次求得 F，换句话说，虽然我们仍有一定的机会能够求解，但无法“保证求解”。

下面回到正题：
假设我们有 k 个鸡蛋可以移动 m 步，考虑某一步 t 应该在哪一层丢鸡蛋？一个正确的选择是在 dp[k-1][t-1] + 1 层丢鸡蛋，结果分两种情况：
- 如果鸡蛋碎了，我们首先排除了该层以上的所有楼层（不管这个楼有多高），
而对于剩下的 dp[k-1][t-1] 层楼，我们一定能用 k-1 个鸡蛋在 t-1 步内求解。
因此这种情况下，我们总共可以求解无限高的楼层。可见，这是一种非常好的情况，但并不总是发生。
- 如果鸡蛋没碎，我们首先排除了该层以下的 dp[k-1][t-1] 层楼，此时我们还有 k 个蛋和 t-1 步，
那么我们去该层以上的楼层继续测得 dp[k][t-1] 层楼。因此这种情况下，我们总共可以求解 dp[k-1][t-1] + dp[k][t-1] + 1 层楼。
容易想象，在所有 m 步中只要有一次出现了第一种情况，那么我们就可以求解无限高的楼层。
但“保证求解”的定义要求我们排除一切运气成分，因此我们只得认为每次移动都遇到第二种情况。于是得到递推公式：

dp[k][t] = dp[k-1][t-1] + dp[k][t-1] + 1

基本的问题已经解决了，但是我们还遗留了一个问题：为什么要选择在 dp[k-1][t-1] + 1 层丢鸡蛋？
现在我们已经知道，如果我们每一步都在 dp[k-1][t-1] + 1 层丢鸡蛋，最终是一定能够求解的。但如果我们选择在更低的层或者更高的层丢鸡蛋会怎样呢？我们分两种情况讨论：
在更低的楼层丢鸡蛋。同样能够“保证求解”，但最终得到的并不是“最大”楼层数，我们没有充分挖掘鸡蛋数和移动次数的潜力，最终求解时会剩余一定量的鸡蛋或移动次数。
在更高的楼层丢鸡蛋。不妨假设高了一层，即在第 dp[k-1][t-1] + 2 层丢鸡蛋。如果鸡蛋碎掉了，我们仍然可以排除该层以上的所有楼层（不管这个楼有多高），但接下来就不好办了，
因为我们剩下的 k-1 个鸡蛋在 t-1 步内只能“保证求解” dp[k-1][t-1] 的楼层，而现在剩余的楼层却是 dp[k-1][t-1] + 1，多了一层，因此无法“保证求解”！
综上，我们用排除法证明了每一步都应该在第 dp[k-1][t-1] + 1 层丢鸡蛋。
"""

# test(n):从第n层楼扔，鸡蛋是否会碎。碎了返回T
# 如果k=2,n=6。有test(1)到test(6)
# test(1)有2种case，
# case1 True=(1,0), 鸡蛋碎了，2-1=1，还剩余1个鸡蛋，测试范围只剩从第0层扔,F-1
# case2 False=(2,5)，鸡蛋没碎，还有2个鸡蛋，测试范围少了一层(剩余2,3,4,5,6)，楼层重新编号为1-5
# 所有分支（test(1)到test(6)），有n种选择。 取min
# 单独分支取max，不对称，确定完整的F
#
# # 边界case
# 比如： N = 1 层楼
# 在 1 层扔，碎了，因为楼层高于 F 才会碎，所以 F < 1 。又因为 0 <= F <= N ，所以能确定 F = 0
# 在 1 层扔，没碎，因为从 F 楼层或比它低的楼层落下的鸡蛋都不会碎，所以 F >= 1 。又因为 0 <= F <= N ，所以能确定 F = 1
if __name__ == '__main__':
    k=1
    n=2
    print(Solution().superEggDrop(k,n))