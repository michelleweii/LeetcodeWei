✅完成于2022/04/28

# Hot100

# 【排序】

## [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)middle

> 快速排序。升序排序后第k大元素的index=k-1。

```python
class Solution(object):
    def findKthLargest(self, nums, k):
        n = len(nums)
        if not nums or k>n:return -1
        # 转求index=n-k
        return self.quick_sort(nums, 0, n-1, n-k)

    # 快速排序，逆序
    def quick_sort(self, nums, left, right, index):
        # 递归出口，仅剩一个元素
        if left>=right:return nums[left]# 如果原地更改的话，就return
        i,j = left, right
        pviot = nums[i] # 基准点
        while i<j:
            # 逆序<=，正序>=
            while i<j and nums[j]>=pviot:
                j-=1
            nums[i] = nums[j]
            while i<j and nums[i]<=pviot:
                i+=1
            nums[j] = nums[i]
        nums[i] = pviot
        # i是分割点
        # # 直接快速排序会超过时间限制
        # 若位置小于index，则在右边找
        if index<i:return self.quick_sort(nums,left,i-1,index) # 【注意】要return！要不然没有结果！
        # 若位置大于index，则在左边找
        elif index>i:return self.quick_sort(nums,i+1,right,index)
        # 若刚好相同，则直接返回即可
        else:return nums[i]
```

拼多多1、头条1、

关于[时间复杂度](https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/)\ [英文](https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60294/Solution-explained/343833) O(N) 的解释：

## [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)middle

> 堆排序。小顶堆，记住heap.api。
>
> 超出堆容量就pop()，堆里维护答案。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        import heapq
        res = []
        q = []
        hashmap = Counter(nums)

        for ch,freq in hashmap.items():
            heapq.heappush(q, (freq,ch))
            if len(q)>k:
                heapq.heappop(q) # 弹最小元素

        return [x[1] for x in q]
# -----------
import heapq
class Solution:
    def topKFrequent(self, nums, k):
        # 1. 构建元素-频率的对应关系，统计元素的频率
        hashmap = {}
        for x in nums:
            hashmap[x] = hashmap.get(x,0)+1
        # 2. 维护小顶堆
        heap  = [] # 默认第一个元素的小顶堆
        for ch,freq in hashmap.items():
            # print(ch,freq)
            if len(heap)>=k:
                if freq>heap[0][0]:
                    heapq.heapreplace(heap, (freq,ch))
            else:

                heapq.heappush(heap, (freq,ch))
        # heap中只存了k个元素，按照第一个元素升序排的
        # for x in heap:
        #     print(x)
        # (1, 3)
        # (2, 2)
        # (3, 1)
        return [item[1] for item in heap]
```

# 【链表】

## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)middle

> 链表的加法。新建一个dummy，链表尾部相加，注意进位（该题不用stk，输入是倒着直接给的）。

```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        dummy = ListNode(-1)
        cur = dummy
        carry = 0 # 进位
        while l1 is not None or l2 is not None:
            # 将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 0，
            # 比如 987 + 23 = 987 + 023 = 1010
            x = l1.val if l1 is not None else 0
            y = l2.val if l2 is not None else 0
            sum = x+y+carry

            carry = sum // 10
            sum = sum % 10
            cur.next = ListNode(sum)
            cur = cur.next

            if l1 is not None:
                l1 = l1.next
            if l2 is not None:
                l2 = l2.next
        # 如果两个链表全部遍历完毕后，进位值为 1，
        # 则在新链表最前方添加节点 1
        if carry==1:
            cur.next = ListNode(carry)

        return dummy.next
```

## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)hard

> 归并排序，将list看做一个数字，本质就是[1,9,3,4,1,5]的归并，先拆成单个元素，两两之间做sort。

```python
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    # 使用分治思想：把2个list当做已经排序好的，准备进行归并的两个数组
    def mergeKLists(self, lists):
        if not lists: return
        """
        将链表list中的链表两两合并改为->归并合并。好难理解哦
        """
        return self.merge_sort(lists, 0, len(lists)-1) # 记录子链表数量

    # 归并排序 [l,mid]+[mid+1,r]
    def merge_sort(self, lists, l, r):
        if l >= r:
            return lists[l] # 链表头节点
        mid = (l+r)//2
        l1 = self.merge_sort(lists, l, mid)
        l2 = self.merge_sort(lists, mid+1, r)
        return self.merge_two_lists(l1, l2)

    # 链表归并，两个链表【合并】成有序
    def merge_two_lists(self, l1, l2):
        p = head = ListNode(-1)
        while l1 and l2:
            if l1.val<l2.val:
                p.next,l1 = l1, l1.next
            else:
                p.next,l2 = l2,l2.next
            p = p.next
        if l1: p.next = l1
        if l2: p.next = l2
        return head.next
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)middle

> 从dummy开始向前走n个节点，当cur.next is None，pre指向向删除的前一个节点，利用pre.next=pre.next.next删除。

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        if not head:return head
        dummy=ListNode(-1)
        dummy.next = head
        pre=cur=dummy
        for i in range(n):
            cur=cur.next

        while cur.next:
            pre=pre.next
            cur=cur.next
        
        pre.next=pre.next.next

        return dummy.next
```

## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)easy

> 链表归并，合并部分。

```python
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        if not l1 and not l2:return None
        if not l1:return l2
        if not l2:return l1
        dummy=cur=ListNode(-1)
        while l1 and l2:
            if l1.val<l2.val:
                cur.next=l1
                if l1:l1=l1.next
            else:
                cur.next=l2
                if l2:l2=l2.next
            cur=cur.next
        
        cur.next = l1 if l1 else l2
        return dummy.next
```

## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)middle

> 「拉平左子树，接到右子树上」
>
> 当我们**后序遍历（左右根）**离开节点时，执行操作「连接左子树到右子树上」
>
> 1、找到左子树的最右节点，将其移到左节点上；

```python
class Solution:
    def flatten(self, root: TreeNode) -> None:
        while root != None:
            # 如果该节点没有左子树，则移动到右子树上，开始新一轮遍历
            if root.left is None:
                root = root.right
            else:
                # 1、找左子树最右边的节点（案例是4）
                pre = root.left
                while pre.right:
                    pre = pre.right
                # 2、将原来的右子树接到左子树的最右边节点（案例5接到4下面）
                pre.right = root.right
                # 3、将root的左子树插入到右子树的地方（1的right接2）
                root.right = root.left
                root.left = None
                # 4、考虑下一个节点（案例由1移动到2）
                root = root.right
        # return
```

## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)easy

> 如何判断一个链表是否有环？快慢指针，如果相遇为有环；fast不相遇且为None，则无环。

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        # 快慢指针
        if not head or not head.next:return False
        slow,fast=head,head # 同时指向head！
        while fast and fast.next:
            slow,fast=slow.next,fast.next.next
            if slow==fast:return True
        return False
```

## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)middle

> 返回环链表入环的第一个节点。快慢指针先判断是否有环，从链表相遇点出发与从头节点出发，再次相遇时，即为入环的第一个节点。
>
> ```
> # a：起点到环入口的节点数（不包括入口）
> # b：环节点数
> # 根据： f=2s （快指针每次2步，路程刚好2倍）
> # f=s+nb (相遇时，刚好多走了n圈), =>推出：s = nb。
> # 从head结点走到入环点需要走：a+nb, 而slow已经走了nb，那么slow再走a步就是入环点了。
> # (如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走a步到入口节点，之后每绕1圈环（ b步）都会再次到入口节点）。)
> # 如何知道slow刚好走了a步？ 从head开始，和fast指针一起走，相遇时刚好就是a步。
> ```

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        # 链表相遇位置到环入口的距离=从链表开始到环入口的距离
        # 1.求相遇点(使用快慢指针)
        if not head or not head.next:return None
        slow, fast = head, head
        while fast and fast.next: 
            slow = slow.next
            fast = fast.next.next
            if slow==fast:break # 停在了相遇节点
        if slow!=fast:return # 如果链表不存在环

        fast = head # 再从head出发，走a个节点
        while fast!=slow:
            fast = fast.next
            slow = slow.next
        return fast
```

## [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)middle

> 双向链表：满足O(1)时间复杂度删除；
>
> 哈希表：满足O(1)时间复杂度查找；
>
> 1、定义双向链表；
>
> 2、定义LRU，包括hashmap，head+tail（是空的，为了方便收尾添加和删除node）；
>
> 3、定义move2tail()方法，**新元素添加到链表末尾**，旧元素移到链表开始位置；
>
> 4、get()：判断key是否存在，如果存在move2tail代表最新访问过，不存在返回-1；
>
> 4、put()：判断key是否存在，如果存在更新链表中的value值；
>
> ​					如果key不存在，判断是否超过容量；超过容量先删除头部元素（不要忘记维护hashmap），
>
> ​												没超过容量，则新建node（不要忘记维护hashmap），将node插入双向链表尾部；

```python
class ListNode:
    def __init__(self, key=None, value=None):
        self.key = key # 不加key没有办法删除最后一个node。因为链表只存了value，不知道它对应的key是多少。
        self.value = value
        self.prev = None
        self.next = None

# 定义LRU缓存
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        # 定义哈希表，为了O(1)时间复杂度get元素
        self.hashmap = {}
        # 新建两个节点 head 和 tail
        # 方便收尾操作元素
        self.head = ListNode()
        self.tail = ListNode()
        # 初始化链表为 head <-> tail
        self.head.next = self.tail
        self.tail.prev = self.head

    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法
    def move_node_to_tail(self, key):
        # 先将哈希表key指向的节点拎出来，为了简洁起名node
        node = self.hashmap[key] # 找到双向链表中，需要操作的节点的位置
        # 先删除该节点（双向链表删除节点，只需要当前指针即可实现）
        node.prev.next = node.next
        node.next.prev = node.prev
        #                 hashmap[key]                 hashmap[key]
        #                      |                            |
        #                      V        -->                 V
        # prev <-> tail  ...  node                prev <-> node <-> tail
        # 再将该节点添加到末尾, 之后将node插入到尾节点前
        # 先自己去连别人
        node.prev = self.tail.prev
        node.next = self.tail
        # 别人再来回连我
        self.tail.prev.next = node
        self.tail.prev = node

    # 访问这个元素，得到这个元素的值return，将该节点移到末尾
    def get(self, key: int) -> int:
        if key in self.hashmap:
            # 如果已经在链表中了，则把它移到末尾（变成最新访问的）
            self.move_node_to_tail(key)
        res = self.hashmap.get(key,-1) # value是一个node，双向链表中的node
        if res == -1:
            return res
        else:
            return res.value # 获取node中的值

    # 添加元素
    # case1: 已经在hashmap中，更新value值，移到末尾
    # case2：不在hashmap中，
    #   case2.1. 没有超过capacity, 创建node，添加到末尾；
    #   case2.2. 超过capacity, 移除链表头部元素（hashmap+doublelinked），创建新node，添加到末尾；
    def put(self, key: int, value: int) -> None:
        if key in self.hashmap:
            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点
            # 但是需要更新字典该值对应节点的value
            self.hashmap[key].value = value
            # 之后将该节点移到末尾
            self.move_node_to_tail(key)
        else:
            # put元素前需要记录是否超过长度，如果超过长度，需要将最早没有访问过head的元素删除，
            # 删除完了，再添加新的元素。
            if len(self.hashmap) == self.capacity:
                # 删除哈希表对应项【删除，更新哈希表】
                self.hashmap.pop(self.head.next.key) # 删除链表头部元素
                # 删除最久没有被访问过的节点，即头节点之后的节点（更新双向链表）
                self.head.next = self.head.next.next
                self.head.next.prev = self.head
            # 如果不在的话就插入到尾节点前
            new_node = ListNode(key,value)
            self.hashmap[key] = new_node # 【添加，更新hashmap】
            # 操作双向链表，将新添加元素接到末尾

            new_node.prev = self.tail.prev # 接前面
            new_node.next = self.tail # 接后面
            self.tail.prev.next = new_node # 接前面(完善)
            self.tail.prev = new_node # 接后面(完善)
```

## [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)middle

> 链表的排序（使用归并）。
>
> 1、找到链表的中点mid；2、分两段开始归并排序的合并过程。
>
> 通过快慢指针找到链表中点。`slow,fast=head,head.next`。

```python
class Solution:
    def sortList_rec(self, head): # 归并递归（从上到下）空间复杂度O(n)
        if not head or not head.next:return head
        slow,fast=head,head  ## 注意
        while fast.next and fast.next.next: ## 注意
            slow=slow.next
            fast=fast.next.next
        mid=slow.next  ## 注意
        slow.next=None
        
        l1,l2=self.sortList(head),self.sortList(mid)
        
        dummy=h=ListNode(-1)
        while l1 and l2:
            if l1.val<l2.val:
                h.next=l1
                l1=l1.next
            else:
                h.next=l2
                l2=l2.next
            h=h.next
        
        h.next=l1 if l1 else l2
        return dummy.next
```

## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)easy

> 走过你走过的路，能再次相遇就是相交节点。

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:return None
        pa,pb=headA,headB
        while pa!=pb:
            pa = pa.next if pa else headB
            pb = pb.next if pb else headA
        return pa
```

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)easy

> 基础题

```python
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def reverseList(self, head):
        if not head or not head.next:return head
        pre,cur = None,head
        while cur:
            tail = cur.next
            cur.next = pre
            pre = cur
            cur = tail
        return pre
```

## [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)middle

> 给定区间进行反转，非hot100。

```python
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        # 定义一个dummyHead, 方便处理
        dummy = ListNode(-1)
        dummy.next = head

        P1 = dummy
        p2 = dummy.next

        # 将指针移到相应的位置
        for _ in range(left-1):
            p1 = p1.next # 将 p1 移动到第一个要反转的节点的前面
            p2 = p2.next # 将 p2 移动到第一个要反转的节点的位置上

        # 头插法插入节点
        # 将 p2 后面的元素删除，然后添加到 p1 的后面。也即头插法
        for i in range(right-left):
          	# 开始头插法
            removed = p2.next
            p2.next = removed.next
            
            removed.next = p1.next
            p1.next = removed
        return dummy.next
```

## [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)hard

> 非hot100，常考题

```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head or not head.next:return head
        # ] pre 已反转
        # [] start,end 正在翻转
        # [ post 未翻转
        dummy=ListNode(-1)
        dummy.next=head
        pre=dummy
        start=end=post=head
        while post:
            for _ in range(k-1):
                if end:end=end.next
            if not end:break # 不满足k个
            post=end.next
            end.next=None
            # 开始翻转----------------
            end=start
            start=self.reverse(start) # LC206 翻转链表
            # 完成翻转-----------------

            # 连起来
            pre.next=start
            end.next=post

            # 开始下一轮
            pre=end
            start,end=post,post

        return dummy.next
```

## [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)easy

> 1、找中点；2、对其中1个链表进行翻转链表；3、逐个元素比较。

```python
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def isPalindrome(self, head):
        mid = self.get_mid(head) # 并不是中点
        head2 = mid.next # 中点是slow.next
        mid.next = None # 断开前半部分两边
        head2 = self.reverse_list(head2) # 反转后半部分链表
        head1 = head
        # 开始对比
        while head1 and head2:
            if head1.val != head2.val:return False
            head1, head2 = head1.next, head2.next

        return True

    def reverse_list(self, head):
        pre = None
        cur = head
        while cur:
            tail = cur.next
            cur.next = pre
            pre = cur
            cur = tail
        return pre

    # 快慢指针求链表中点
    def get_mid(self, head):
        slow, fast = head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        # mid = slow
        return slow
```

# 【双指针】

## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)middle

>right不断右移，找到可行解。left再右移，找到最优解。
>
>hashmap维护每个字母出现的次数，如果有一个字母多了，一定是right新加的字母多了。

```python
# 定义两个指针i,j。表示当前扫描到的子串是[i,j]，
# 扫描过程中维护一个哈希表，表示[i,j]中每个字符出现的次数。
# 1、指针j向后移动一位，同时将哈希表s[j]的计数+1，hash[s[j]]++；
# 2、假设j移动前的区间[i,j]中没有重复字符，则 j 移动后，只有s[j]可能出现2次。<重点>
# 因此我们不断向后移动i，直至区间[i,j]中s[j]的个数等于1为止；
class Solution(object):
    # 以s[j]为右端点，向左延生，最远能延生到的i的位置
    def _lengthOfLongestSubstring(self, s):
        hash_map = {}
        i = 0
        res = 0
        for j in range(len(s)):
            hash_map[s[j]] = hash_map.get(s[j],0)+1
            while hash_map[s[j]]>1:
                hash_map[s[i]] = hash_map[s[i]]-1
                i += 1 # i是最左的有边界
            res = max(res,j-i+1)
        return res
```

扩展题目 [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string)。

## [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)middle

> 找到s中所有p的异位词 的起始index。s = "cbaebabacd", p = "abc"，return [0,6]。
>
> hashmap维护每个字母出现的次数，当前窗口的字符个数与p的字符个数相同时，记录答案。
>
> 如何判断当前窗口字符个数与p的个数相同呢？
>
> 如果有一个字母多了，一定是right新加的字母多了。将该字母通过left移出，如果`当前窗口维护的单词长度=len(p)`，记录答案。

```python
class Solution(object):
    # 套用模板解法
    def findAnagrams(self, s, p):
        from collections import Counter
        res = []
        n, m = len(s), len(p)
        if n<m:return res

        window_map = {} # window 记录当前窗口中的字符
        p_map = Counter(p) # Counter({'a': 2})
        left, right = 0, 0

        while right < n: # 遍历长的字符串
            window_map[s[right]] = window_map.get(s[right], 0) + 1
            # 通过窗口左边界的右移left++，把所有多余的字符移出去
            # 与L3不同，这里是与map做比较
            while window_map.get(s[right], 0) > p_map.get(s[right], 0): ### 这里不同
              	# 类似LC3，重复的只可能是right新入的
                window_map[s[left]] = window_map.get(s[left], 0) - 1 
                left += 1
            if right-left+1 == m: # 题目要求输出不同
                res.append(left)
            right += 1 # 扩充右边界
        return res
```

## [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)middle

> 反向双指针，谁短谁就++or--，移动指针前先计算面积。

```python
# 在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 -1 变短：
# 若向内 移动短板 ，水槽的短板 min(h[i], h[j]) 可能变大，因此下个水槽的面积 可能增大 。
# 若向内 移动长板 ，水槽的短板 min(h[i], h[j]) 不变或变小，因此下个水槽的面积 一定变小 。
class Solution:
    def maxArea(self, height):
        i, j = 0, len(height)-1
        res = 0
        while i<j:
            # 注意，这里每次移动的都是短板！！！
            if height[i]<height[j]:
                res = max(res, height[i]*(j-i))
                i+=1
            else:
                res = max(res, height[j]*(j-i))
                j-=1
        return res
```

## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)middle

> 三个指针，cur指向当前主要的元素，left=cur+1，right=n-1，在`[left,right]`范围内找sums=0的值。
>
> 当前元素找完了，就找下一个cur++。注意不能有重复解。

```python
class Solution(object):
    def threeSum(self, nums):
        n = len(nums)
        res = []
        # 特例
        if (not nums or n < 3):
            return res
        # 对nums升序 nlogn
        nums.sort()
        for i in range(n): ## 第一个循环
            # 遍历每个元素，以每个元素为原点开始向右区间计算
            if nums[i]>0:return res # 因为升序，所以后面不可能有三个数加和等于0，直接返回结果。
            # 剪枝，当前元素已经遍历过
            if i>0 and nums[i]==nums[i-1]:continue # 本题的难点在于如何去除重复解。## 这种方式回溯里也会用到
            left = i+1
            right = n-1
            while left<right: ## 第二个循环
                cur_res = nums[i] + nums[left] + nums[right]
                if cur_res == 0:
                    res.append([nums[i],nums[left],nums[right]])
                    # 判断左界和右界是否和下一位置重复，去除重复解。(本题重点) ### 本题的难点在于如何去除重复解。
                    # 并同时将 L,R 移到下一位置，寻找新的解
                    while left<right and nums[left]==nums[left+1]:left+=1
                    while left<right and nums[right]==nums[right-1]:right-=1
                    left += 1 # 不要忘了，否则不能退出while循环
                    right -= 1
                elif cur_res>0: # 右边right太大了，right--
                    right-=1
                else: # 左边left太小了，left++
                    left+=1
        return res
```

平安科技校招1，汽车之家1

## [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)middle

> 从后向前，找一个较小的数（前），找一个比较小数稍微大一点的数（后），两者交换，
>
> （后半段）小数后面，升序排序。123465->123546。

```python
class Solution:
    def nextPermutation(self, nums):
        if len(nums)<1:return nums
        # i是小数、k是大数
        i,j,k = len(nums)-2, len(nums)-1, len(nums)-1
        # 找到i,j // find: A[i]<A[j]
        while i>=0 and nums[i]>=nums[j]:
            i -= 1
            j -= 1
        # 寻找k，大数【这一步老忘】[2,3,1]->[3,1,2]
        if i >= 0: # 不是最后一个排列
            # // find: A[i] < A[k]
            while nums[i]>=nums[k]: # 找到一个比nums[i]稍微大一点的数进行交换
                k-=1 # j后的数必然降序，现在需要找到比nums[i]大的数
            # // swap A[i], A[k]
            nums[i],nums[k] = nums[k],nums[i]
        # // reverse A[j:end]
        # 将j后面的数字升序
        # 切片操作不是原地操作，所以nums[i+1:].sort()并不是对原数组排序
        # print(i,j)
        nums[j:] = sorted(nums[j:])
```

## [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)middle

> 先按第一个元素sort，再按第二个元素sort。
>
> 判断两个元素交界处是否可以合并。

```python
class Solution:
    def merge(self, intervals):
        if not intervals:return intervals
        intervals.sort() # 默认先按第一个元素升序，再按第二个元素升序
        # print(intervals) # [[1, 3], [2, 6], [8, 10], [15, 18]]
        l, r = 0, 1 # 双指针的初始化
        while r<len(intervals): # 这里一定要动态的变化
            x1,y1 = intervals[l]
            x2,y2 = intervals[r]
            if x2>y1:
                l,r = l+1,r+1
            else:
                intervals[l] = [x1, max(y1,y2)]
                intervals.pop(r) # 删除指定index
        return intervals
```

## [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)middle

> 三个指针，划分出0、1、2三个区间。只移动0和2的指针，1自然就有序了。

```python
# all in [0, left) = 0
# all in [left, cur) = 1
# all in [right, len-1] = 2
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        left,cur = 0,0 # 标记0，1
        right = n # 标记2
        while cur<right:
            # 只移动 0，2 
            # 1 自然就到位置了
            if nums[cur]==0:
                nums[left],nums[cur]=nums[cur],nums[left]
                left+=1
                cur+=1
            elif nums[cur]==2:
                right-=1
                nums[cur],nums[right]=nums[right],nums[cur]
            elif nums[cur]==1:
                cur+=1
        return nums
```

## [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)hard

> 先right++寻找可行解，找到可行解，再left++寻找最优解。
>
> 什么时候算找到了可行解呢？counter(t)中每个字符，当前窗口curwindow中都包括；
>
> 当把need中不需要的元素都移出就找到了最优解。

```python
class Solution:
  	from collections import Counter
    def minWindow(self, s, t):
        ls = len(s)
        lt = len(t)
        if not s or not t or ls < lt:
            return ''

        # # 最小覆盖子串长度
        res = ls + 1 # 初始赋值为一个不可能达到的数
        left, right = 0, 0

        # 对t中的字符计数
        curwindow = Counter(t) # 当前滑动窗口中需要的各元素的数量
        need_cnt = len(t) # 所需元素的总数量,=3则为还差3个元素(还需要几个元素可以成为t)
        start = 0 # start是最小覆盖串开始的index

        # [left, right) # 一开始l,r都是0，带入[)中，[0,0)这个区间是空的
        # 右指针向右扩展，遍历s，长的那个字符串
        while right < ls:
            # s[right] 右指针看见的元素
            # 先后顺序不能变化 比如aa
            if curwindow[s[right]] > 0: # 如果需要这个元素
                need_cnt -= 1
            curwindow[s[right]] -= 1 # 把右边的字符加入窗口，不需要的就{R:-1}即可

            # 寻找最优解
            # 步骤一：滑动窗口包含了所有T元素
            if need_cnt == 0: 
              	# 步骤二：增加left，排除多余元素，<0说明是多余元素
                while (left<right and curwindow[s[left]]<0):  
                    curwindow[s[left]] += 1
                    left += 1 # 指针右移
                # 出while循环的时候，left位于不能再右移的位置

                if (right-left+1<res):
                    res = right-left+1 # 最小覆盖子串长度
                    start = left # 再从这个位置开始向右扩展

                #【这里】破坏窗口性质，寻找下一个最优解
                # left向右移动后窗口肯定不能满足了，重新开始循环
                # left是要前进一位的，开始寻找下一个满足条件的滑动窗口
                curwindow[s[left]] += 1 # 该元素移出了，则还需要该元素
                left += 1
                need_cnt += 1

            right += 1

        return '' if res > ls else s[start:start+res]
```

## [*238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)middle

> 先赋值为1，向右进行一次累乘（先赋值再累乘）；再赋值为1，向左进行一次累乘（先赋值再累乘，赋值时要乘以第一遍的结果）。
>
> ```
> 原数组：       [1       2       3       4]
> 左部分的乘积：   1       1      1*2    1*2*3
> 右部分的乘积： 2*3*4    3*4      4      1
> 结果：        1*2*3*4  1*3*4   1*2*4  1*2*3*1
> ------------------------------------------------------------------------------------------
> 当前位置的结果就是它左部分的乘积再乘以它右部分的乘积。因此需要进行两次遍历，第一次遍历用于求左部分的乘积，
> 第二次遍历在求右部分的乘积的同时，再将最后的计算结果一起求出来。
> 时间复杂度O(N)
> ```

```python
class Solution:
    def productExceptSelf(self, nums):
        if not nums:return nums
        p = 1
        res = [1 for _ in range(len(nums))]
        # -> 第一次遍历用于求左部分的乘积
        for i in range(len(nums)):
            res[i] = p # 自己的位置
            p *= nums[i]
        p = 1
        # <- 第二次遍历在求右部分的乘积
        for j in range(len(nums)-1, -1, -1):
            res[j] *= p
            p *= nums[j]
        return res
```

## [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)easy

> 同向双指针，l,r=0,0。l指向0元素，r指向非0的元素，遇到非0的元素交换。

```pythoN
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        l,r=0,0 # 0元素，非0元素
        while r<n:
            if nums[r]!=0:
                nums[l],nums[r]=nums[r],nums[l]
                l+=1 # 交换之后，l指向非0元素。因此要++，指向0元素。     
            r+=1 # r找不是0的元素
            
        return nums
```

## [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)middle

> 快慢指针。
>
> 数组下标index和数nums[index]构成映射关系`index->nums[index]->nums[nums[index]]`；
>
> 1. 数组中有一个重复的整数 <==> 链表中存在环；
> 2. 找到数组中的重复整数 <==> 找到链表的环入口；

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # 快慢指针
        # https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/
        # 重点理解映射关系，index->nums[index]->nums[nums[index]]
        # 1、先找到相遇节点
        slow,fast=0,0
        slow,fast=nums[slow],nums[nums[fast]]
        while slow!=fast:
            slow=nums[slow] # 慢指针移动
            fast=nums[nums[fast]] # 快指针移动
        # 2、再从起点出发，同时进行
        fast=0
        while slow!=fast:
            slow=nums[slow]
            fast=nums[fast]

        return slow
```

## [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)middle

> LC3加强版。双指针。right++，超出的时候，left++，当长度一致时，记录答案。

```python
"""
解题思路
（1）初始化 left = right = 0 把索引 <左闭右闭> 区间 [left, right] 当做一个 "窗口"。
（2）不断增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符长度与字符串 t 的长度相等。
（3）此时，停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串长度不再符合要求。
    同时，每增加一次 left，就要更新一轮结果。
（4）重复第 2 和第 3 步，直到 right 到达字符串 s 的尽头。
其中，第 2 步相当于在寻找一个 "可行解"，第 3 步相当于在判断这个可能的 "可行解"，最终找到 "最优解"。
"""
class Solution(object):
    # 套用模板解法
    def findAnagrams(self, s, p):
        from collections import Counter
        res = []
        n, m = len(s), len(p)
        if n<m:return res

        window_map = {} # window 记录窗口中的字符
        p_map = Counter(p) # Counter({'a': 2})
        left, right = 0, 0

        while right < n: # 遍历长的字符串
            window_map[s[right]] = window_map.get(s[right], 0) + 1
            # 通过窗口左边界的右移left++，把所有多余的字符移出去
            while window_map.get(s[right], 0) > p_map.get(s[right], 0): # 与L3不同，这里是与map做比较
                window_map[s[left]] = window_map.get(s[left], 0) - 1 # 类似LC3，重复的只可能是right新入的
                left += 1
            # print(window_map)
            if right-left+1 == m:
                res.append(left)
            right += 1 # 扩充右边界
        return res
```

# 【树】

## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)easy

> 左右根。

```python
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:return []
        self.res = []
        self.dfs(root)
        return self.res

    def dfs(self,root):
        if not root:return
        self.dfs(root.left) # 左
        self.res.append(root.val) # 根
        self.dfs(root.right) # 右
```

## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)middle

> BST的中序遍历是递增的。

```python
class Solution(object):
    def isValidBST1(self, root):
        if not root:return root
        res = [] # 存中序遍历的结果
        self.helper(root, res)
        for i in range(1, len(res)):
            if res[i-1] >= res[i]: # 如果不是递增的，false
                return False
        return True

    def helper(self,root,res):
        # 二叉树中序遍历
        if not root:return root
        self.helper(root.left, res)
        res.append(root.val)
        # print(res)
        self.helper(root.right, res)


# 方法二，递归版本，每个结点都满足左小于它，右大于它的性质
#     二叉搜索树的性质就是左子树中所有节点的值都小于根节点，右子树中所有节点的值都大于根节点
#     直接递归，验证左子树的时候，将左子树值的最小范围和最大范围作为参数传入，同理右子树也是如此
    def isValidBST(self, root):
        return self.check_bst(root, float("-inf"), float("inf"))

    # 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val
    def check_bst(self, node, left, right):
        # 如果是空节点
        if not node: return True
        # 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
        if not left < node.val < right:
            return False
        # 左子树分别bst
        # 右子树分别bst，后面两个参数不是很理解（最小范围、最大范围）
        # 限定左子树的最大值是 root.val，右子树的最小值是 root.val
        return (self.check_bst(node.left, left, node.val)
                and self.check_bst(node.right, node.val, right))
```

## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)easy

> 递归2个指针，分别指左子树、右子树，判断是否一样。

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:return True
        return self.dfs(root.left,root.right)

    def dfs(self,p1,p2):
        if not p1 and not p2:return True
        elif not p1 and p2:return False
        elif not p2 and p1:return False
        elif p1.val!=p2.val:return False
        return self.dfs(p1.left,p2.right) and self.dfs(p1.right,p2.left)
```

## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)middle

> 模板题。

```python
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:return []
        res = []
        queue = [root]
        while queue:
            cur_size,cur_path = len(queue),[]  # 当前层
            for i in range(cur_size):
                node=queue.pop(0)
                cur_path.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(cur_path[:])
        return res
```

## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)easy

> 递归，分别求左子树、右子树最大值，+1是自己本身。

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:return 0
        left=self.maxDepth(root.left) # 左子树高度
        right=self.maxDepth(root.right) # 右子树高度
        return max(left,right)+1
```

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)middle

> 遍历中序遍历，存入hashmap中，key为值，value为index。为快速在中序遍历中找到根节点。

```python
class Solution:
    def __init__(self):
        self.hashmap = {}

    def buildTree(self, preorder, inorder):
        # 中序结果hash，方便定位node所在下标，用于分割左右子树
        for i in range(len(inorder)):
            self.hashmap[inorder[i]] = i

        self.preorder = preorder
        self.inorder = inorder

        return self.dfs(0, len(preorder)-1, 0, len(inorder)-1)

    def dfs(self, pl, pr, il, ir):
        """
        :param pl: param pr: 前序遍历起始、结束位置
        :param il: param ir: 中序遍历起始、结束位置
        """
        # 定义出口
        if pl>pr:
            return None
        # 遍历节点，开始递归
        root = TreeNode(self.preorder[pl])
        k = self.hashmap[self.preorder[pl]]
        # k-il 中序遍历中，左子树的长度
        # ir-k 中序遍历中，右子树的长度
        # 得到 pl+k-il 前序遍历中，左子树的长度
        # 不断找左子树、找右子树
        root.left = self.dfs(pl+1, pl+k-il, il, k-1)
        root.right = self.dfs(pl+k-il+1, pr, k+1, ir)
        return root
```

## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)middle

```python
class Solution: # 后序遍历，dfs
    def flatten(self, root: TreeNode) -> None: 
        def dfs(root):
            if not root:return root
            l=dfs(root.left)
            r=dfs(root.right)
            if l:
                l.right=root.right
                root.right=root.left
                root.left=None
            if r:return r
            if l:return l
            return root
        dfs(root)
```

## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)easy

> 该题的基础题是LC104.求二叉数的最大深度。
>
> **对于树中的每一个结点，都要把它视为根节点，然后比较所有结点的左子树和右子树的最大深度之和。**
>
> 以某节点node为列，当它作为路径的时候：只能选max(left,right)的最大值；
>
> 当它作为根的时候，需要left+right（直径求的是边的数量）；

```python
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root:return 0
        self.res = 0
        self.depth(root)
        return self.res

    def depth(self, root):
        # 先考虑最下层的空节点
        if not root:return 0
        # 考虑中间层的左边的深度以及右节点的深度
        left_depth = self.depth(root.left)
        right_depth = self.depth(root.right)
        # 每个结点都要去判断左子树 + 右子树的高度是否大于self.max，更新最大值
        # # 【如果当做路径】每个节点都去挑战最大值！！
        self.res = max(self.res, left_depth+right_depth) # 求边的数量
        # 【如果当做节点】
        return max(left_depth, right_depth)+1 # 求左右子树高度，求节点的数量
```

## *[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)hard

> 该题的基础题是LC543。
>
> 当node作为节点时：求left+node+right的和去挑战全局最大值；
>
> 当node作为根时：node.val+max(left,right)；

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        if not root:return root.val
        self.res=float("-inf")

        def dfs(root):
            if not root:return 0
            left_gain=dfs(root.left)
            right_gain=dfs(root.right)
            # 做节点的时候
            insum = root.val+left_gain+right_gain
            self.res = max(self.res,insum)
            # 做路径的时候
            # left_gain,right_gain有可能是负数
            return max(0,max(left_gain,right_gain)+root.val) # 防止root.val也是负数
        
        dfs(root)
        return self.res
```

```python
class Solution:
    def __init__(self):
        self.max_sum = float("-inf") # 最大路径和

    # 返回经过root的单边分支最大和， 即Math.max(root, root+left, root+right)
    def maxPathSum(self, root):
        if not root:return 0
        # 返回当前子树能向父节点“提供”的最大路径和。
        # 即，一条从父节点延伸下来的路径，能在当前子树中捞取的最大收益。
        def dfs(root): # max_gain
            if not root:return 0 # 遍历到null节点(叶子节点)，收益0
            left_gain, right_gain = dfs(root.left), dfs(root.right) # 左\右子树提供的最大路径和
            # 【某子树内部最大值】
            in_maxsum = left_gain + root.val + right_gain # 当前子树内部的最大路径和
            #【某子树向外部提供的最大值】 innerMax 是当前node作为root的时候的最大值，也就是说只有在当前节点是root的时候才能够同时选左边和右边；
            # 不然的话，作为路径上的一份子，只能选择左边或者右边。【对外只能作为路径上的一份子】
            # 有很多节点都可以当根节点，比较一下哪个根能做结果。
            self.max_sum = max(self.max_sum, in_maxsum) # 挑战最大纪录
            #【全局最大值】
            out_sum = root.val + max(0, max(left_gain, right_gain)) # 当前子树对外提供的最大和,只能走左边or右边。（不要最外面的max也可以）
            return max(out_sum, 0) # 当前子树能向父节点“提供”的最大路径和

        dfs(root)
        return self.max_sum
```

## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)easy

> 递归翻转。

```python
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:return root
        root.left,root.right=root.right,root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```

## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)middle

>递归左右子树，如果两边都找到了，祖先就是root。

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:return root
        if root is p or root is q:return root  ### 不要忘记了！！
        left=self.lowestCommonAncestor(root.left,p,q)
        right=self.lowestCommonAncestor(root.right,p,q)
        if left and right:return root
        if not left:return right
        if not right:return left
```

## [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)hard

> 序列化：先序遍历记录str；
>
> 反序列：每次弹出根节点，构建树；

```python
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# dfs思路
class Codec:
    # 选择前序遍历，是因为 根|左|右根∣左∣右 的打印顺序，在反序列化时更容易定位出根节点的值。
    # 遇到 null 节点也要翻译成特定符号，反序列化时才知道这里是 null
    def serialize(self, root):
        """Encodes a tree to a single string.
        :type root: TreeNode
        :rtype: str
        """
        if not root: return 'x' # 遍历到 null 节点
        left = self.serialize(root.left)
        right = self.serialize(root.right)
        return str(root.val)+','+str(left)+','+str(right) # 按  根,左,右  拼接字符串
        # return str(root.val)+','+left+','+right
        # 看图,前序遍历序列化 1,2,x,x,3,4,x,x,5,x,x

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        :type data: str
        :rtype: TreeNode
        """
        nodelist = data.split(',')
        return self.build_tree(nodelist)

    def build_tree(self, data):
        root = data.pop(0)

        if root=='x': # 是X，返回null节点
            return None

        root = TreeNode(root)
        root.left = self.build_tree(data)
        root.right = self.build_tree(data)
        return root
```

## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)middle

> 求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。不要求从根节点出发。
>
> 回溯+前缀和。
>
> 前缀和（index=i到j的和）`nums[i--j]=presums[j+1]-presums[i]`。
>
> 于是，1、计算nums[a]共出现几次；
>
> 2、维护hashmap定义，该值出现了几次。
>
> 3、左右子树回溯，回溯的时候统计到当前节点的和。
>
> 4、回溯结束时，返回上一节点，要将加了cur节点的路径，的个数-=1。
>
> 递推关系：
>
> ```python
> # 前缀和的计算
> # 闭区间[i, j]的区间和 = prefix_sum[j+1] – prefix_sum[i]
> # 起始位置+[0]
> nums=[0, 6, 5, 2, 2, 5, 1, 9, 4]
> presum = [0]*(len(nums)+1)
> for i in range(len(nums)):
>     presum[i+1] = presum[i] + nums[i]
> # print(presum) # [0, 0, 6, 11, 13, 15, 20, 21, 30, 34]
> 
> # presum[a..b]=target
> #             =nums[b+1]-nums[a]
> # => target=cur当前结尾的值-nums[a]
> # => nums[a]=cur当前结果的值-target
> # => 求nums[a]共出现几次？
> ```

```python
class Solution: 
    def pathSum(self, root: TreeNode, targetSum):
        if not root: return 0
        self.count = 0
        self.target = targetSum
        self.hashmap = {}
        self.hashmap[0] = 1 # # 前缀和为0的数量有1个。默认nums[-1]=0
        self.dfs(root, root.val) # (树的根节点，当前前缀和的值)
        return self.count

    # 具体操作细节退化到lc560
    # key: 前缀和
    # value: key 对应的前缀和的个数
    # 快速找到满足以 cur=b 为「路径结尾」的、使得路径总和为 targetSum的目标「路径起点」有多少个。
    def dfs(self, root, cursums):
        # 为啥子没有出口？ if left, if right, 就会结束dfs
        # if not root:return # 加不加都会过？为什么？前序遍历不加会报错
        # 以 当前节点 b 为 终点
        self.count += self.hashmap.get(cursums-self.target, 0)
        # 有多少节点 a 满足 sum[a...b] = targetSum，
        # b 是当前的sums, 结尾节点的值
        # 维护，这个节点值共出现几次
        self.hashmap[cursums] = self.hashmap.get(cursums, 0) + 1
        # 开始回溯 ; 以 当前节点 b 为路径的一部分
        if root.left:self.dfs(root.left, cursums+root.left.val) # 以root.left为结尾，更新路径上的值
        # sums+root.left.val 自带回溯效果
        if root.right:self.dfs(root.right, cursums+root.right.val)
        # 当子树结束时，应当把子树从哈希表中移除 (回溯：将一切复原，然后结束)
        self.hashmap[cursums] = self.hashmap.get(cursums,0)-1
```

## [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)middle

> 返中序遍历，维护全局变量当前和。

```python
class Solution:
    def __init__(self):
        self.sum = 0

    def convertBST(self, root): #Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:return root
        self.traverse(root)
        return root

    # 反中序遍历
    def traverse(self, root):
        if not root:return
        self.traverse(root.right)
        self.sum += root.val
        root.val = self.sum
        self.traverse(root.left)
```

## [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)easy

>同时前序遍历2个树，更新的值赋在root1上。

```python
# 总结下递归的条件：
# 1、终止条件：树 1 的节点为 null，或者树 2 的节点为 null
# 2、递归函数内：将两个树的节点相加后，再赋给树 1 的节点。再递归的执行两个树的左节点，递归执行两个树的右节点
class Solution:
    def mergeTrees_mine(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root2:return root1
        if not root1:return root2
        root1.val=root1.val+root2.val
        root1.left=self.mergeTrees(root1.left,root2.left)
        root1.right=self.mergeTrees(root1.right,root2.right)
        return root1
```

- 总结：树的题目，简单来说先考虑当前情况的求解，然后再对左右子树进行递归，之后返回answer。

# 【单调栈】

## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)hard

> 单调递减栈，cur元素出栈时是最低的，前后两个柱子都比cur高。雨水面积累加。

```python
class Solution:
    def trap(self, height):
        if len(height) <= 1: return 0
        res, stk = 0, []
        for i in range(len(height)):
            # 当 当前元素比栈顶元素大时(维护非严格单调减)
            # 当找到一根比前面高的柱子，就可以计算接到的雨水
            while stk and height[i]>height[stk[-1]]:
                cur = stk[-1]
                stk.pop() # 删掉栈顶元素index
                # 可以加哨兵解决该问题
                if not stk: break # 必须左边还有，才能计算红色部分的体积
                # left和i取min
                left = stk[-1]
                h = min(height[i],height[left])-height[cur]
                w = i-left-1 # 为什么求宽度-1？题目要求是柱子
                res += h*w
            stk.append(i)
        return res
```

## [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)hard

> 单调递增栈，枚举以每个柱形（栈顶元素）为高度的最大矩形的面积。以cur元素为面积的高，向两边扩散。
>
> w: i-left-1，栈顶不断pop尝试left的最小值。
>
> 对于每一个位置，我们都这样操作，得到一个矩形面积，求出它们的最大值。

```python
class Solution:
    def largestRectangleArea(self, heights):
        heights = [0]+heights+[0]  # 插入两个哨兵
        stk = []
        res = 0
        for i in range(len(heights)):
            # 单调递增栈
            # 如果当前i元素小于栈顶元素，说明栈顶元素找到了它右边第一个比它小的元素
            # 在栈顶元素左侧，都是比栈顶元素小的。while一直向前计算，
            # 直到恢复单调递增栈
            while stk and heights[i]<heights[stk[-1]]: # <才是求比栈顶元素右边小的right
                h = heights[stk[-1]]
                stk.pop()
                res = max(res, (i-stk[-1]-1)*h) # 为什么求宽度-1？题目要求是柱子
            stk.append(i)
        return res
```

## [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)hard

> 单调递增栈，二维的LC48，矩阵每行当做一个list，每行都去调用LC48，取最大值。

```python
class Solution:
    def maximalRectangle(self, matrix):
        n = len(matrix) # n行
        if not n:return 0
        m = len(matrix[0]) # m列
        if n==1 and m==1:return int(matrix[0][0])
        heights = [0 for _ in range(m)]
        # 将每行看做一个新的底，构建新的柱状图，有多少行，就有多少个柱状图
        res = 0
        for i in range(n):
            for j in range(m):
                # 以每行i为底座，一直想上累加（向上延伸）
                if matrix[i][j]=='1':heights[j]+=1
                else: heights[j] = 0
            res = max(res, self.helper(heights))
        return res

    # 维护单调递增栈
    def helper(self, heights):
        heights = [0]+heights+[0]  # 插入两个哨兵
        stk = []
        ans = 0
        for i in range(len(heights)):
            while stk and heights[i]<heights[stk[-1]]:
                h = heights[stk[-1]]
                stk.pop()
                left = stk[-1]
                w = i-left-1 # i是h为最矮柱的右边界
                ans = max(ans, w*h) # 以h为最矮柱的最大面积
            stk.append(i)
        return ans
```

## [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)easy

> 单调递减栈，最小值在栈顶stk[-1]。

```python
class MinStack:
    def __init__(self):
        self.min_stk = []
        self.stk = []

    def push(self, val: int) -> None:
        self.stk.append(val)
        if not self.min_stk or val<=self.min_stk[-1]: # 单调递减栈
            self.min_stk.append(val)

    def pop(self) -> None:
        if self.stk.pop() == self.min_stk[-1]:
            self.min_stk.pop()

    def top(self) -> int:
        return self.stk[-1]

    def getMin(self) -> int:
        return self.min_stk[-1] # 最小值在栈顶
```

## *[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)hard

> 单调递减栈，栈顶stk[0]是最大值，栈底stk[-1]是最小值。

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        res=[]
        stk=[] # 单调递减栈
        for i in range(n):
            while stk and nums[i]>nums[stk[-1]]:
                stk.pop()
            stk.append(i) # 先append
					
          	# 超过窗口的弹出
            while stk and i-stk[0]>=k:
                stk.pop(0)
						
            # 在k的范围内，记录ans
            if i+1>=k:
                res.append(nums[stk[0]])

        return res
```

百度校招1面

## [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)middle

> 2遍单调栈。正序，单调递增栈；逆序，单调递减栈。
>
> 题目：找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。nums = [2,6,4,8,10,9,15]。

```python
class Solution:
    # 单调栈!!! 【核心】
    # 正序遍历，找比cur值小(找与题意相反，即不符合)，单调递增栈
    # 逆序遍历，找比cur值大，单调递减栈
    def findUnsortedSubarray_stk(self, nums):
        n = len(nums)
        stk = []
        left, right = n, 0 # 设置一个取不到的值即可
        # 1、正序遍历，单调递增栈
        for i in range(n):
            while stk and nums[i]<nums[stk[-1]]:
                left = min(left, stk[-1])  # 这里再确认
                stk.pop()
            stk.append(i)
        # 2、逆序遍历，单调递减栈
        for i in range(n-1, -1, -1):
            while stk and nums[i]>nums[stk[-1]]:
                right = max(right, stk[-1])
                stk.pop()
            stk.append(i)

        return max(0, right-left+1)
```

## [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)middle

> 单调递减栈。
>
> ```
> temperatures = [73,74,75,71,69,72,76,73]，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。
> ```

```python
class Solution:
    def dailyTemperatures(self, temperatures): #List[int]) -> List[int]:
        n = len(temperatures)
        stk = []
        res = [0]*n
        for i in range(n):
            # 单调递减栈
            while stk and temperatures[i]>temperatures[stk[-1]]:
              # 当前元素大于栈顶元素，可以记录answer
                index = stk.pop() # 大于
                res[index] = i-index
            stk.append(i)
        return res
```

# 【二分】

## [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)hard

> 题目两个有序list，找出两个list的中位数。
>
> 要求算法的时间复杂度应该为 `O(log(m+n))`;
> 如果是先归并排序，再返回中位数，时间复杂度 `O(m+n)`;
>
> 思路：转为求第k小数，即取index=k-1的数作为ans。
>
> 1. 保证len1的长度永远比len2小；
> 2. 考虑特殊情况1：num1为空，num2中idx=k-1的值为ans；
> 3. 考虑特殊情况2：k=1，min(num1[start],num2[start])为ans；
> 4. 开始二分，每次在num1和num2中比较num[k//2-1]的值，如果num1该值较小，则nums1前面的数字通通不要；num2同理；每次减少一半比较，k也同样缩小。
>
> ```
> """
> 【关于left和right的解释】
> // 总数为奇数的情况: 则取中间那个数+ 总数为偶数的情况: 则取中间偏前那个数
> // 总数为奇数的情况: 也是取中间那个数+ 总数为偶数的情况: 则取中间偏后那个数
> int left = (len1 + len2 + 1) / 2;   
> int right = (len1 + len2 + 2) / 2;  
> // 求两次，从而将奇偶问题解决。
> //      如果是偶数: 则需要寻找中间前后两位 (此时left=right-1);
> //      如果是奇数: 则只需寻找中间那一位   (此时left=right)
> """
> ```
>
> - 时间复杂度：每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 O(log(k)，而 k=(m+n)/2，所以最终的复杂也就是O(log(m+n))。

```python
class Solution:
    def findMedianSortedArrays(self, nums1, nums2) -> float:
        lens1,lens2=len(nums1),len(nums2)
        # 因为数组是从索引0开始的，因此我们在这里必须+1，即索引(index=k+1)的数，才是第k个数。
        # 将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k
        left = (lens1+lens2+1)//2 # left_k
        right = (lens1+lens2+2)//2 # right_k
        # 应对m+n奇偶数两种情况的通用做法。如果m+n为偶数 那么取值为中间两值，如果为奇数则第left right为同一个数
        return (self.get_kthmin(nums1,0,lens1-1,nums2,0,lens2-1,left) \
                + self.get_kthmin(nums1,0,lens1-1,nums2,0,lens2-1,right)) \
               *0.5
        # 【第一次这里不理解，为什么求left，求right】
        # // 二分查找
        # // 一半儿一半儿的排除。假设我们要找的中位数为 合并数组后的 第k位数，我们可以每次循环排除掉 k/2 个数
        #
        # // 关键点
        # // (1)合并后数组的元素个数有奇偶两种情况：
        # //      偶数，需要找两次。结果为第len/2或(len+1)/2 和 第(len+2)/2或(len+3)/2 两个数的平均值，
        # //      奇数，需要找一次。结果为第(len+1)/2或(len+2)/2的那个数
        # //    综合起来,只需要两次 即第 (len+1)/2 和 (len+2)/2 的那两个数，再取平均值，即可兼顾奇偶两种情况
        # //
        # // (2)两种可能的情况： 即递归中两中返回值情况 (len1==0 或 k==1)
        # // (3)确定nums1比nums2范围更小，从而确定了其中一种返回条件(len==0)
        # // (4)当数组范围大小 len<k/2 时，参与比较的元素下标就不能是k/2-1，而是len-1
        # //
        # // 之后就是根据比较大小的结果 更新区间和k值

    # k是所求中位数的一半，还是看图
    # 求第k小的数
    def get_kthmin(self, nums1, start1, end1, nums2, start2, end2,k):
        # 1. 特殊处理
        len1 = end1-start1+1
        len2 = end2-start2+1
        # 让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1
        # 就是如果len1长度小于len2，把getKth()中参数互换位置，即原来的len2就变成了len1，即len1，永远比len2小
        if len1>len2:return self.get_kthmin(nums2,start2,end2,nums1,start1,end1,k)
        # 如果一个数组中没有了元素，那么即从剩余数组nums2的其实start2开始加k再-1

        # 因为k代表个数，而不是索引，那么从nums2后再找k个数，那个就是start2 + k-1索引处就行了。因为还包含nums2[start2]也是一个数。因为它在上次迭代时并没有被排除
        # 情况一：
        if len1==0:return nums2[start2+k-1]

        # 如果k=1，表明最接近中位数了，即两个数组中start索引处，谁的值小，中位数就是谁(start索引之前表示经过迭代已经被排出的不合格的元素，即数组没被抛弃的逻辑上的范围是nums[start]--->nums[end])
        # 情况二：求第一小的数
        if k==1: return min(nums1[start1], nums2[start2])
        ###########################################################
        # 完成特殊处理
        ###########################################################

        # 2.求k//2
        # 为了防止数组长度<k//2,每次比较都会从当前数组所生长度和k/2作比较，取其中的小的(如果取大的，数组就会越界)
        # 然后数字如果len1<k//2，表示数组经过下一次遍历就会到末尾，然后后面就会在那个剩余len2数组中寻找中位数
        # 二分
        i = start1+min(k//2,len1)-1 # 第k=3小的数字，index=2，所以要减一
        j = start2+min(k//2,len2)-1 # nums2中第j位是比较位置

        # 3.删除元素
        # nums2中index<=j的元素都不要了
        if nums1[i]>nums2[j]:
            return self.get_kthmin(nums1,start1,end1,nums2,j+1,end2,k-(j-start2+1))
        else:
            return self.get_kthmin(nums1,i+1,end1,nums2,start2,end2,k-(i-start1+1))
```

## [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)middle

> 两次二分，第一次二分找到旋转数组最小值。
>
> 判断target是在哪一段，第二次二分在局部范围内进行查找。
>
> 核心：`while (n-1)>=0 and nums[0]==nums[n-1]:n-=1 # 恢复二段性 ` ;

```python
class Solution(object):
    def search(self, nums, target):
        # 需找到自增区间、旋转区间
        n = len(nums)-1
        while n>=0 and nums[0]==nums[n]:n-=1 # 恢复二段性
        l, r = 0, n

        # 第一次二分，寻找旋转数组最小值
        if nums[0]>nums[n]:
            while l<r:
                mid = (l+r)//2
                if nums[mid]>=nums[0]:
                    # print('nums[mid]>nums[0]', nums[mid],nums[0])
                    l=mid+1
                else:
                    r=mid
            print("旋转数组最小值", nums[r], "下标是", r)
            if target==nums[l]:return l

            if target>=nums[0]:
                l,r=0,r # l,r=0,r-1 说明-1也是对的
            else:
                l,r=l,n

        # 第二次二分，寻找target下标
        while l<r:
            mid=(l+r)//2
            if nums[mid]<target:
                l = mid+1
            else:
                r = mid
        return l if nums[l]==target else -1
```

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)middle

> 左边一次二分，查找左边界；右边一次二分，查找右边界；
>
> ```
> 输入：nums = [5,7,7,8,8,10], target = 8
> 输出：[3,4]
> ```

```python
class Solution(object):
    def searchRange(self, nums, target):
        if not nums:return [-1,-1]
        res = []
        # 二分左边界
        l,r=0,len(nums)-1
        while l<r:
            mid = (l+r)//2
            if nums[mid]<target:
                l=mid+1
            else:
                r=mid
        if nums[r]!=target:return [-1,-1]
        res.append(r)

        # 二分右边界
        l,r=0,len(nums)-1
        while l<r:
            mid = (l+r+1)//2
            if nums[mid]>target:
                r=mid-1
            else:
                l=mid
        # print(l, nums[l])
        # if nums[l]!=target:return [-1,-1]
        res.append(l)
        return res
```

## [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)middle

> 从右上角开始二分。左侧数都小于它；右侧数都大于它。

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
      	m,n=len(matrix),len(matrix[0])
        i,j=0,n-1
        
        while i<m and j>=0:
            t = matrix[i][j] # 右上角
            if target>t:
                i+=1 # 向下走
            elif target<t:
                j-=1 # 向左走
            else:return True
        
        return False
```

## [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)middle

> 题目：给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。
>
> ```
> 输入：nums = [1,3,4,2,2]
> 输出：2
> ```
>
> 抽屉原理：先猜一个数（有效范围 [left..right] 里位于中间的数 mid），然后统计原始数组中 小于等于 mid 的元素的个数 cnt。如果数字大于mid，那么重复的区间就在[left,mid]中。

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        l = 1
        r = len(nums)
        while l<r:
            # 找到对什么二分：统计原始数组中 <= mid 的元素的个数 cnt
            mid = l+r>>1
            sum = 0
            for x in nums:
                if x>=1 and x<=mid:sum+=1
            # 如果遍历一遍输入数组，统计小于 等于 4 的元素的个数，
            # 如果小于等于 4 的元素的个数 严格 大于 4 ，说明重复的元素一定出现在整数区间 [1..4]
            # 根据抽屉原理，小于等于 4 的个数如果严格大于 4 个，此时重复元素一定出现在 [1..4] 区间里
            if sum>mid:
                # 重复元素位于区间 [left..mid]
                r=mid
            else:
                l=mid+1
        return r
```

# 【动态规划】

## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)middle

> 1、定义状态
>
> `dp[i][j]` 表示：子串 s[i..j] 是否为回文子串，这里子串 s[i..j] 定义为左闭右闭区间，即可以取到 s[i] 和 s[j]。
>
> s[i..j]，所以必然有i<=j；
>
> 2、状态转移方程：`dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]`;
>
> 3、考虑初始化：单个字符一定是回文串，`dp[i][i] = true`。

```python
class Solution:
    def dp(self, s):
        if not s or len(s) == 1: return s
        n = len(s)

        start,maxlen=0,1
        dp = [[False] * n for _ in range(n)]

        for i in range(n):
            dp[i][i] = True # 单个字符即回文

        # s[i..j]，所以必然有i<=j
        for j in range(1,n):
            for i in range(0,j):
                if s[i]!=s[j]:
                    dp[i][j]=False
                else: # s[i]==s[j]
                    if j-i+1<=3:
                        dp[i][j]=True # aa, aba
                    else:
                        dp[i][j] = dp[i+1][j-1] # 从两边向里面
                # 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置
                if dp[i][j] and j-i+1>maxlen:
                    maxlen = j-i+1
                    start = i
        return s[start:start+maxlen]
```

## [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)hard

> p由. *组成，p是否可以匹配s。
>
> 1、定义状态：`dp[i][j]` 表示 s 的前 i 个字符s[0:i-1]，是否能被 p 的前 j 个匹配p[0:j-1]。
>
> 2、状态转移：
>
> > s[i-1]==p[j-1] or p[j-1]=='.' : `dp[i][j]=dp[i-1][j-1]`;
>
> > p[j-1]=='\*' and s[i-1]==p[j-2] or p[j-2]=='.'：比如aa, a\*, aaac\*;
> >
> > 1. *前字符出现0次，`dp[i][j]=dp[i][j-2]`; 
> > 2. *前字符出现1次，`dp[i][j]=dp[i-1][j-2]`;
> > 3. *前字符出现多次，`dp[i][j]=dp[i-1][j]`;
> >
> > p[j-1]=='*' and  s[i-1]!=p[j-2] ：比如aa与ab\*，干掉b；
> >
> > 1. `dp[i][j]=dp[i][j-2]`
>
> 3、考虑初始化：
>
> > 1. `dp[0][0]=True`，s为空，p为空，能匹配上。
> >
> > 2. p为空串，s不为空串，肯定不匹配。
> >
> > 3. s为空串，但p不为空串，要想匹配，只可能是右端是星号，它干掉一个字符后，把 p 变为空串。
> >
> >    `if p[j-1]=='*': dp[0][j] = dp[0][j-2]`

```python
class Solution(object):
    def isMatch(self, s, p):
        if not s or not p:return False
        s_len, p_len = len(s), len(p)
        # s、p 串是否匹配，取决于：最右端是否匹配、剩余的子串是否匹配
        # dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配
        dp = [[False] * (p_len+1) for _ in range(s_len+1)]
        # 出口，用p的前0个字符去匹配s的前0个字符
        # 1、s为空，p为空，能匹配上
        dp[0][0] = True
        # 2、p为空，s不为空，必为false(boolean数组默认值为false，无需处理)
        # 3、s为空，p不为空，由于*可以匹配0个字符，所以有可能为true
        """
        base case
        p为空串，s不为空串，肯定不匹配。
        - s为空串，但p不为空串，要想匹配，只可能是右端是星号，它干掉一个字符后，把 p 变为空串。
        s、p都为空串，肯定匹配。
        """
        for j in range(1, p_len+1):
            if p[j-1]=='*': dp[0][j] = dp[0][j-2]

        # 4、填表
        for i in range(1, s_len+1):
            for j in range(1, p_len+1):
                # dp[i][j]:s的前i个字符s[0:i-1]与p的前j个字符p[0:j-1]是否匹配
                if s[i-1]==p[j-1] or p[j-1]=='.':
                    dp[i][j] = dp[i-1][j-1]
                # *特判, *可以让它前面的字符出现0-n次
                if p[j-1]=='*':
                    if s[i-1]==p[j-2] or p[j-2]=='.':
          # dp[i][j] = dp[i-1][j-2] # *让它前面的字符出现1次,  aa与a*以及 aa与.* ,dp[i-1][j-2]
          # dp[i][j] = dp[i-1][j-3] # *让它前面的字符出现0次， aa与aac* ,dp[i][j-2]
          # 还可以dp[i][j] = dp[i][j-2]
          # dp[i][j] = dp[i-1][j] # *让它前面的字符出现多次， aaaaaaa与a*
                        dp[i][j] = dp[i][j-2] or dp[i-1][j-2] or dp[i-1][j]
                    elif s[i-1]!=p[j-2]: # a与ab*, 干掉b
                        dp[i][j] = dp[i][j-2]

        return dp[s_len][p_len]
```

## [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)hard

>1、定义状态：dp[i] 表示以 i 结尾的最长有效括号；s[i]必有；
>
>2、状态转移：
>
>```
>1. 当 s[i] 为 (,dp[i] 必然等于 0，因为不可能组成有效的括号；
>2. 那么 s[i] 为 )
>    2.1 当 s[i-1] 为 (，那么 dp[i] = dp[i-2] + 2；
>    2.2 当 s[i-1] 为 ) 并且 s[i-dp[i-1] - 1] 为 (，那么 dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]；
>```
>
>3、考虑初始化：都是0；

```python
# ()(()，结果是2，因为答案要求连续
class Solution(object):
    def dpSolution(self,s):
        # dp数组，其中第 i 个元素表示以下标为 i 的字符结尾的最长有效子字符串的长度
        n = len(s)
        if n<2: return 0
        dp = [0] * n # dp[i] 表示以 i 结尾的最长有效括号
        res = 0
        for i in range(n):
            if i>0 and s[i]==')':
                # () 情况
                if s[i-1]=='(':
                    dp[i]=dp[i-2]+2 # 在历史匹配数上+2
                # #)()(())) 情况，就是(())
                # 当前i的对称点索引是否存在
                # 和s[i]配对对位置，并判断其是否是 (即可。和其配对对位置为：i−dp[i−1]−1。
                elif s[i-1]==')' and i-dp[i-1]-1>=0 and s[i-dp[i-1]-1]=='(':
                    dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]
                if dp[i]>res:
                    res=dp[i]
        return res
```

## [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)easy

>必须包含nums[i]；<u>**子数组要求下标连续。**</u>
>
>```
>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
>输出：6
>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
>```
>
>1、状态定义：`dp[i]`表示以 `nums[i]` 结尾 的 **连续** 子数组的最大和。
>
>2、状态转移：`dp[i] = max(nums[i], dp[i-1]+nums[i])`; 不选前面的和，选前面的和；
>
>3、考虑初始化：0；

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dp=[0]*n # 以nums[i]结尾的最大子数组和

        dp[0]= nums[0] # 【注意】这里

        for i in range(1,n):
            dp[i]= max(nums[i],dp[i-1]+nums[i])
        
        return max(dp)
```

携程校招1面

## [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)middle

> **<u>子序列下标可以不连续。</u>**
>
> 1、状态定义：dp[i]代表以nums[i]结尾的最长递增子序列长度。
>
> 2、状态转移：`dp[i] = max(dp[i], dp[j]+1) if nums[i]>nums[j]`。
>
> 3、考虑初始化：都是1。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        # dp[i]以nums[i]为结尾的最长递增子序列的长度
        if len(nums)==0:return 0
        dp = [1 for _ in range(len(nums))]
        for i in range(1, len(nums)):
            for j in range(i):
                # 当前元素要比之前的元素大，才可以跟在后面，构成上升
                if nums[i]>nums[j]:
                    dp[i] = max(dp[i], dp[j]+1) # dp[j] 是之前元素的最大值
        return max(dp)
```

## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)middle

> 矩阵从左上走到右下，有几种不同的路径。
>
> 1、状态定义：`dp[i][j]`: 到达网格`(i,j)`时, 共有 `dp[i][j]` 种走法。
>
> 2、状态转移：只能向下或者向右移动一步，`dp[i][j] = dp[i-1][j]+dp[i][j-1]`;
>
> 3、考虑初始化：初始化边界，只有1种路径；

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0 for j in range(n)] for i in range(m)] # m*n
        # dp[0][0] = 1，从(0,0)到达(0,0)只有一条路径
        dp[0][0] = 1
        # 初始化 dp[0][j] 和 dp[i][0]
        # 边界，列
        for i in range(1, m):
            dp[i][0] = 1 # dp[i][0] = dp[i-1][0]+1
        # 边界，行
        for j in range(1, n):
            dp[0][j] = 1 # dp[0][j] = dp[0][j-1]+1

        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j]+dp[i][j-1]

        return dp[m-1][n-1] # return dp[-1][-1]
```

## [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)middle

> 左上角到右下角的路径，使得路径上的数字总和为最小。
>
> 1、状态定义：`dp[i][j]`为到达位置`[i,j]`时的最小路径和；
>
> 2、状态转移：每次只能向下或者向右移动一步，`dp[i][j]=min(dp[i-1][j]+grid[i][j],dp[i][j-1]+grid[i][j])`；
>
> 3、考虑初始化：初始化边界，只能一种方向累加；

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m,n=len(grid),len(grid[0])
        # 由[0][0]到达[m-1][n-1]的最小路径和
        dp = [[0]*n for _ in range(m)]
        
				dp[0][0] = grid[0][0]
        for i in range(1,m):
            dp[i][0]=dp[i-1][0]+grid[i][0]
        
        for j in range(n):
            dp[0][j]=dp[0][j-1]+grid[0][j]        

        for i in range(1,m):
            for j in range(1,n):
                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]

        return dp[m-1][n-1]
```

## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)easy

> 1、状态定义：dp[i]代表爬到有i个台阶的楼顶，有dp[i]种方法；

```python
class Solution(object):
    def climbStairs(self, n):
        if n<=2:return n
        dp = [0]*(n+1) # 爬到有i个台阶的楼顶，有dp[i]种方法。
        dp[1] = 1 # 1阶台阶,只有一种方式(1)
        dp[2] = 2 # 2阶台阶,有两种方式(1+1, 2)
        for i in range(3,n+1):
            dp[i] = dp[i-1]+dp[i-2] # 可以爬 1 或 2 个台阶
        return dp[n]
```

## [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)hard

> 1、状态定义：`dp[i][j]` 代表 word1 中前 i 个字符word1[0:i-1]，变换到 word2 中前 j 个字符word2[0:j-1]，最短需要操作的次数；
>
> 2、状态转移：有替换、删除、增加3种操作；
>
> `dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1`，返回最少操作数；
>
> > `dp[i-1][j]`word1删除1个字符，变为word2；
> >
> > `dp[i][j-1]`word1增加1个字符；
> >
> > `dp[i-1][j-1]`word1替换1个字符；
>
> 3、考虑初始化：需要考虑 word1 或 word2 一个字母都没有，即全增加/删除的情况，所以预留`dp[0][j]` 和 `dp[i][0]`

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1,len2=len(word1),len(word2)
        dp = [[0]*(len2+1) for _ in range(len1+1)]  # 由word1前i个单词转为word2前j个单词所需要的最少操作数
				# 初始化，当另一个是空串时
        for i in range(len1+1):
            dp[i][0] = i # word2是空的，只能删除
        for j in range(len2+1):
            dp[0][j] = j # word1是空的，只能增加

        for i in range(1,len1+1):
            for j in range(1,len2+1):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
                # dp[i-1][j]删除
                # dp[i][j-1]增加
                # dp[i-1][j-1]替换

        return dp[-1][-1]
```

度小满1面、叮咚1面

## [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)middle

> 卡特兰数。掌握递推关系。
>
> 给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？
>
> 1、状态定义：dp[i] 表示`i`个元素的二叉搜素树<u>***有多少种***</u>，以某个节点为根结点的树形态数 = 左子树的形态数量 * 右子树的形态数量。
>
> 2、转移状态：`G(n) = G(0)*G(n-1) + G(1)*(n-2) + ... + G(n-1)*G(0)`

```python
"""
假设n个节点存在二叉排序树的个数是G(n)，令f(i)=以i为根的二叉搜索树的个数；
即有: G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)
n为根节点，当i为根节点时，其左子树节点个数为[1, 2, 3, ..., i-1]，右子树节点个数为[i+1, i+2, ...n]，
所以当i为根节点时，其左子树节点个数为(i-1)个，右子树节点为(n-i)，即f(i) = G(i-1) * G(n-i),
上面两式可得: G(n) = G(0)*G(n-1) + G(1)*(n-2) + ... + G(n-1)*G(0)

举个例子，dp[5]指的就是5个连续数字可以组成的二叉搜索树的个数
这5个数字不一定是[1,2,3,4,5]，也可以是[7,8,9,10,11]，只要是i个连续的数，就一定可以排列出dp[i]个二叉搜索树
"""
# 为什么是乘而不是加呢？
class Solution:
    def numTrees(self, n):
        dp = [0]*(n+1) # dp[i] 表示i个元素的二叉搜素树有多少种
        dp[0], dp[1] = 1, 1
        # 将1至n分别作为根结点时的数量累加即为结果 dp[n]
        for i in range(2, n+1):
            # 将除去根结点之外的（n-1）个子节点做排列组合
            for j in range(i):
                # G(n) = G(0)*G(n-1) + G(1)*(n-2) + ... + G(n-1)*G(0)
                dp[i] += dp[j]*dp[i-1-j]
        return dp[n]
```

## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)easy

> 贪心更简单；可以交易无限次，在价格最低的时候买入，差价最大的时候卖出。

```python
class Solution(object):
    # 贪心
    # 在价格最低的时候买入，差价最大的时候卖出
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        profit=-1 # 首日利润为
        cost=prices[0] # 首日消耗
        for i in range(1,n):
            profit=max(profit,prices[i]-cost)
            cost=min(cost,prices[i]) # 找到最低那天的价格
        return max(profit,0)
      
    # 只要考虑当天买和之前买哪个收益更高，当天卖和之前卖哪个收益更高
    # dp[i]以prices[i]为结尾的子数组的最大利润（以下简称为 前 i 日的最大利润 ）
    # 扩展可以交易两次（买卖算一次交易）求最大值
    def maxProfit_dp(self, prices):
        if not prices: return 0
        dp = [0 for _ in range(len(prices))]
        cost = prices[0]
        for i in range(1, len(prices)):
            cost = min(cost, prices[i])
            dp[i] = max(dp[i-1], prices[i]-min(cost, prices[i]))
        return max(dp)
```

## [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)middle

> 1、状态定义：`dp[i][j]` 表示在下标为 i 这一天状态为 j 时，我们手上拥有的金钱数。
>
>   **j=0 现金状态，j=1股票状态。**
>
> 2、状态转移：卖出股票有冷冻。
>
> ```
> dp[i][0]= max(dp[i-1][0], dp[i-1][1]+nums[i]) #现金状态
> dp[i][1]= max(dp[i-1][1], dp[i-2][0]-nums[i]) #持股状态
> ```
>
> 3、考虑初始化：

```python
# 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
# 0 持有现金
# 1 持有股票，只有从第一天开始交易以后才有此状态，没有交易前i<0时，该状态都是不存在-int('inf')
class Solution:
    def maxProfit(self, prices):
        if not prices: return 0
        if len(prices) == 1: return 0
        n = len(prices)
        dp = [[0 for _ in range(2)] for _ in range(n)]
        # 初始化
        dp[0][0] = 0 # 第0天，持有现金为0
        dp[0][1] = -prices[0] # 第0天，持有股票-prices[0]
        dp[1][0] = max(0, prices[1]-prices[0])# 第1天，持有现金(需要第0天买入，第1天卖出)
        dp[1][1] = max(-prices[0], -prices[1])# 第1天，持有股票(第0天买股票，第1天可以不操作)
        # 状态转移
        for i in range(2, n):
            # 股票：买股票，可以什么都不做+可以从持有现金状态转为持有股票状态
            # 现金：卖股票，可以什么都不做+可以从股票状态转为现金状态
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
            # 卖出 ---- 冷冻期 ----  买入
            dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i])
        return dp[-1][0]
```

## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)middle

> 有顺序的完全背包。
>
> 1、状态定义：dp[i] 表示 s 的前 i 位是否可以用wordDict中的单词表示。
>
> 2、状态转移：`dp[i] = dp[i] or dp[i-sz]`，不选word or 选word；
>
> 3、考虑初始化：dp[0] = true 表示空串且合法。

```python
# 考虑顺序，外层target，内层arrs。内循环正序。
class Solution:
    def wordBreak(self, s: str, wordDict):
        # dp[i] 表示以 i 结尾的字符串是否可以被 wordDict 中组合而成
        dp = [False] * (len(s)+1)
        dp[0] = True

        for i in range(1, len(s)+1): # target
            for word in wordDict: # arrs
                sz = len(word)
                if i-sz>=0 and s[i-sz: i]==word:  #word in wordDict:
                    dp[i] = dp[i] or dp[i-sz]
                    # 不选word dp[i]
                    # 选word dp[i-sz]
        return dp[-1]
```

## [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)middle

> 子数组是连续的。考虑负负得正（最小积）、正正得正（最大积）两种情况。
>
> 1、状态定义：
>
> ```python
> imax=[0]*n # 以nums[i]结尾所能构成的最大积 
> imin=[0]*n # 以nums[i]结尾所能构成的最小积
> ```
>
> 2、状态转移：最大积的可能情况有：元素i自己本身，上一个最大积与i元素累乘，上一个最小积与i元素累乘；
>
> ```python
> imax[i]=max(imax[i-1]*nums[i],imin[i-1]*nums[i],nums[i])
> imin[i]=min(imax[i-1]*nums[i],imin[i-1]*nums[i],nums[i])
> ```
>
> 3、考虑初始化：0。

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        # 下标要连续 
        n=len(nums)
        imax=[0]*n # 以nums[i]结尾所能构成的最大积 
        imin=[0]*n # 以nums[i]结尾所能构成的最小积

        imax[0],imin[0]=nums[0],nums[0]
        res=nums[0]
        for i in range(1,n):
            # 最大积的可能情况有：元素i自己本身，上一个最大积与i元素累乘，上一个最小积与i元素累乘；
            imax[i]=max(imax[i-1]*nums[i],imin[i-1]*nums[i],nums[i])
            imin[i]=min(imax[i-1]*nums[i],imin[i-1]*nums[i],nums[i])
            res = imax[i] if imax[i]>res else res
        return res
```

## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)middle

> 1、状态定义：dp[i]表示`i`位置能偷到的最高金额；
>
> 2、状态转移：相邻的不能偷`dp[i]=max(dp[i-1],dp[i-2]+nums[i])`；
>
> 3、考虑初始化：注意dp[0]=nums[0]；

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n<2:return nums[0]
        dp = [0]*n # i位置能偷到的最高金额
        dp[0]=nums[0]
        dp[1]=max(nums[0],nums[1])
        for i in range(2,n):
            dp[i]=max(dp[i-1],dp[i-2]+nums[i])
        return dp[n-1]
```

## [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)middle

> 树型dp。
>
> 1、状态定义：dp下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。
>
> 2、状态转移：偷当前节点`val1 = cur.val + left[0] + right[0] # 那么cur的左右孩子要跳过, left[0] + right[0]`；
>
> 不偷当前节点`val2 = max(left[0], left[1]) + max(right[0], right[1]) # 如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，`。
>
> 3、考虑初始化：[]。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 树形DP就是在树上进行递归公式的推导
class Solution:
    def rob(self, root: TreeNode):
        if not root:return 0 # 没有node时
        if not root.right and not root.left: return root.val # 只有一个根节点时
        # dp = # 注意这里没有dp数组，遍历树的时候记录结果
        # 长度为2的数组，0：不偷，1：偷
        # 当前节点，不偷所能获得的最大金额，偷所能获得的最大金额
        dp = self.rob_tree(root)
        return max(dp[0],dp[1])

    # 后序遍历
    # 首先明确的是使用后序遍历。 因为通过递归函数的返回值来做下一步计算。
    def rob_tree(self, cur):
        if not cur:return [0, 0] # 确定终止条件，在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0
        left = self.rob_tree(cur.left)
        right = self.rob_tree(cur.right)
        # 偷cur
        # 那么cur的左右孩子要跳过, left[0] + right[0]
        val1 = cur.val + left[0] + right[0]
        # 不偷cur
        val2 = max(left[0], left[1]) + max(right[0], right[1])
        # 如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，
        # 所以：val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return [val2, val1]
```

## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)middle

> 1、状态定义：`dp[i][j]`表示以`nums[i][j]`为右下角，所构成的最大正方形边长；
>
> 2、状态转移：`dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1`；
>
> 3、考虑初始化：i=0，j=0的行和列，初始化根据`nums[i][j]`赋值。

```python
class Solution:
    def maximalSquare(self, matrix): #List[List[str]]) -> int:
        if not len(matrix) or not len(matrix[0]):return 0
        m,n = len(matrix),len(matrix[0])
        # # 状态定义：dp[i][j]表示以matrix[i][j]为右下角，所构成的最大边长
        dp = [[0] * n for _ in range(m)]

        # 初始化
        max_side = 0
        for i in range(n):
            dp[0][i] = int(matrix[0][i])
            if dp[0][i]>max_side:max_side=dp[0][i]
        for i in range(m):
            dp[i][0] = int(matrix[i][0])
            if dp[i][0]>max_side:max_side=dp[i][0]

        for i in range(1, m):
            for j in range(1,n):
                if matrix[i][j]=='1':
                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1
                    max_side = max(max_side, dp[i][j])
        return max_side*max_side
```

## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)middle

> 无顺序的多重背包。
>
> 每个硬币可以无限取，构成金额需要的硬币个数。
>
> 1、状态定义：dp[i]为构成金额i的最优解，即凑成总金额所需的最少的硬币个数。
>
> 2、状态转移：`dp[n]=min(dp[n-coin]+1,dp[n])  # 选该硬币，不选该硬币
>
> 3、考虑初始化：`dp=[0]*(amount+1)`。

```python
class Solution(object):
    def coinChange2022(self, coins, amount):
        max_int = 2 << 31
        dp = [max_int]*(amount+1) # 构成金额i的最少硬币数
        dp[0] = 0  # 构成金额0，需要0个硬币数
        for coin in coins: # 外层遍历arrs
            for i in range(amount+1): # 内层遍历target
                # 物品体积不能大于背包容量
                if coin<=i:
                    dp[i] = min(dp[i], dp[i-coin]+1)
        return -1 if dp[amount]==max_int else dp[amount]
# 设dp[i]为构成金额i的最优解,即凑成总金额所需的最少的硬币个数
# 那么dp[1]=1,dp[2]=1,dp[5]=1,因为coins中有此金额，直接拿来用即可
# dp[i]=min(dp[i-1],dp[i-2],dp[i-5])+1
```

## [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)easy

> 题目：计算从 0 到 n 的每个整数的二进制表示中的 1 的数目。
>
> 1、状态定义：dp[i]表示数字i的二进制中含个1的个数。
>
> 2、状态转移：偶数：`dp[i] = dp[i//2]`；奇数：`dp[i]=dp[i-1]+1`。
>
> 3、考虑初始化：`dp = [0]*(n+1)`。

```python
"""
数字分为奇数、偶数，
针对奇数有：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
#           举例：
#          0 = 0       1 = 1
#          2 = 10      3 = 11
针对偶数有：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，
除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。
#            举例：
#           2 = 10       4 = 100       8 = 1000
#           3 = 11       6 = 110       12 = 1100
"""
class Solution:
    def countBits(self, n): #int) -> List[int]:
        dp = [0]*(n+1) # 状态定义：数字i的二进制中含dp[i]个1。
        # 根据奇偶性开始遍历计算
        for i in range(1,n+1):
            # 如果是奇数
            if i%2==1:
                dp[i]= dp[i-1]+1
            # 如果是偶数
            else:
                dp[i] = dp[i//2]
        return dp
```

## [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)middle

> 01背包。**内循环倒序。**
>
> 先做一点数学题，找到target，target等于sum(nums)//2是等和。
>
> 1、状态定义：dp[i] 表示是否存在和为 i 的 组合。
>
> 2、状态转移：dp[i]=dp[i-num] or dp[i]，选or不选。
>
> 3、考虑初始化：dp[0]=True，什么都不取，存在和为0的组合。

```python
# 题目等价于：是否可以从输入数组中挑选出一些正整数，使得这些数的和 等于 整个数组元素的和的一半。
# target 是什么？sum//2
# 是否可以将这个数组分割成两个子集，使得两个子集的元素和相等
# dp[i] 表示是否存在和为 i 的 组合。
class Solution:
    def canPartition(self, nums):
        sum = 0
        for num in nums:
            sum+=num
        # 特判：如果是奇数，就不符合要求
        if sum%2==1:return False
        target = sum//2
        # 01背包--dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，
        # 每个数只能用一次，使得这些数的和恰好等于 j
        dp = [False for _ in range(target+1)]
        dp[0] = True # 什么都不取 # dp[i] 表示是否存在和为 i 的 组合
        # 【模板】外循环遍历 arrs，内循环遍历 target，且内循环倒序
        for x in nums: # 遍历物品体积
            for j in range(target, x-1, -1): #j>=x # 遍历背包容量，背包容量必然要>=物品体积
                dp[j] = dp[j] or dp[j-x] # 不选or选
        return dp[target]
```

## [494. 目标和](https://leetcode-cn.com/problems/target-sum/) middle

> 01背包。
>
> 题目要求从数组里选择数字，只使用`+`or`-`，来构成target。
>
> 数学推导：
>
> ```
> # 我们想要的 target = 正数和positive+负数和negtive=x-y
> # 已知 x 与 y 的和是数组总和：x + y = sum
> # 可以求出 x = (target + sum) / 2 # 令『正值部分』的绝对值总和为x。
> # 问题转换为：只使用+运算符，从 nums 凑出 x 的方案数。
> ```
>
> 1、状态定义：`dp=[0]*(target+1) # 求和结果为i的表达式数目`。
>
> 2、状态转移：`dp[i]=dp[i-num]+dp[i]`，数目和都是相加的关系。
>
> 3、考虑初始化：`dp[0]=1`。

```python
class Solution:
    def findTargetSumWays(self, nums, target):
        sums = sum(nums)
        if target>sums or (sums + target) % 2 == 1: return 0
        positive = (target+sums)//2
        dp = [0]*(positive+1) # 表示和为 i 的 num 组合有 dp[i] 种。
        dp[0] = 1 # 表示只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。
        for num in nums:
            for i in range(positive, num-1, -1):  # 内循环倒序
                # f[i][j]=f[i−1][j]+f[i−1][j+nums[i−1]]
                dp[i] = dp[i] + dp[i-num] # i >= num
                # dp[i] 不选
                # dp[i-num] 选
        return dp[positive]
```

## [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)middle

> 1、状态定义：`dp[i][j]`表示s[i]到s[j]是否能构成回文串，True or False。维护一个count统计子串个数。
>
> 2、状态转移：`dp[i][j]=dp[i+1][j-1]`， i in [0,n] ，j in [1,i)。
>
> 3、考虑初始化：全False。

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        if n==1:return n
        dp=[[False]*n for _ in range(n)]

        res=0
        for i in range(n):
            dp[i][i]=True
            res+=1
        
        for j in range(1,n):
            for i in range(0,j):
                if s[i]!=s[j]:dp[i][j]=False
                else:
                    if j-i+1<=3 and j-i+1>1:
                        dp[i][j]=True
                    else:
                        dp[i][j]=dp[i+1][j-1]
                    if dp[i][j]:res+=1
                    
        return res 
```

## [312. 戳气球](https://leetcode.cn/problems/burst-balloons/)hard

> 区间dp
>
> 1、状态定义：`dp[i][j]`表示气球区间i-j之间的最优结果，即最大金币数。
>
> 2、状态转移：选or不选，
>
> ```python
> dp[i][j] = max(dp[i][k]+nums[i]*nums[k]*nums[j]+dp[k][j], 
>                dp[i][j])
> ```
>
> 3、考虑初始化：3个循环，1循环区间长度，2循环区间内的起始点i~j，3循环分割点。

```python
# 在区间(i,j)中，找到划分点k，得到(选)dp[i][k]+nums[k]+dp[k][j]，(不选)dp[i][j]
class Solution:
    def maxCoins(self, nums):
        nums = [1]+nums+[1]
        n = len(nums)
        dp = [[0]*n for _ in range(n)]
        for lens in range(2, n): # 区间长度
            for i in range(0, n-lens): # 以 i 为 开头
                j = i+lens # # 以 j 为 终点
                # k是(i,j)区间内最后一个被戳的气球
                for k in range(i+1, j):  # k取值在(i,j)开区间中, # 以 k 为分割点，进行分治
                    dp[i][j] = max(dp[i][k]+nums[i]*nums[k]*nums[j]+dp[k][j], \
                                   dp[i][j])

        return dp[0][-1] 
```

# 【图论】

## [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)middle

> 回溯：组合问题，有start_index。

```python
class Solution(object):
    def __init__(self):
        self.res = []
        self.path = ""
        self.hash_map = {'0': "", '1': "", '2': "abc", '3': "def", '4': "ghi", '5': "jkl", '6': "mno", '7': "pqrs", '8': "tuv", '9': "wxyz"}

    def letterCombinations(self, digits):
        if not digits:return self.res
        self.dfs(digits,0) # 0是从digits的第0位开始
        return self.res

    def dfs(self,digits,start_index):
        # 回溯函数没有返回值

        # 定义出口，终止条件就是如果index 等于 输入的数字个数（digits.size）了（本来index就是用来遍历digits的）
        if len(self.path) == len(digits):
            self.res.append(self.path)
            return
        # 确定单层遍历逻辑
        # 首先要取index指向的数字，并找到对应的字符集
        # 然后for循环来处理这个字符集，代码如下：
        letters = self.hash_map[digits[start_index]]  # 取出数字对应的字符集
        for letter in letters: # 控制树的第2层
            self.path += letter
            self.dfs(digits, start_index+1) # digits的下一个字符串 #递归，注意index+1，下一层要处理下一个数字了
            self.path = self.path[:-1] #  回溯
```

## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)middle

> 回溯，括号问题核心<u>left括号数</u>不能大于<u>right括号数</u>，右括号'）'一定要比左括号'（'多；

```python
class Solution(object):
    def generateParenthesis(self, n):
        if not n:return []
        self.path, self.res = [], []
        self.backtrace(n, n)
        return self.res

    def backtrace(self, left, right):
        """
        :param left:左括号还有几个可以使用
        :param right:右括号还有几个可以使用
        :return:
        """
        # 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分
        if left==0 and right==0:
            self.res.append(''.join(self.path[:]))
            return

        # 右括号'）'一定要比左括号'（'多
        # ）剩余[(()]，怎么都不能满足条件
        if left>right:
            return

        if left>0:
            # 下面3句可以用这1句代替
            # dfs(path + "(", left - 1, right, res);
            self.path.append('(')
            self.backtrace(left-1, right)
            self.path.pop()

        if right>0:
            self.path.append(')')
            self.backtrace(left, right-1)
            self.path.pop()
```

## [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)middle 

> 组合问题，有start_index，利用i>start_index去重；
>
> dfs出口：sum(path)==target；
>
> ```
> 输入: candidates = [2,3,5], target = 8
> 输出: [[2,2,2,2],[2,3,3],[3,5]]
> ```

```python
class Solution:
    def __init__(self):
        self.res = []
        self.path = []

    def combinationSum2(self, candidates, target):
        candidates.sort() # 首先要排序
        self.dfs(candidates,target,0,0)
        return self.res

    # i+1表明一个数字只能使用一次
    def dfs(self,candidates,target,sums,start_index):
        # 判断出口
        if sums == target:
            self.res.append(self.path[:])
            return

        # 树层开始循环遍历
        for i in range(start_index,len(candidates)):
            # 剪枝
            if sums + candidates[i] > target:
                return
            # 要对同一树层使用过的元素进行跳过
            # 【核心】candidates有重复元素，需要去重
            if i>start_index and candidates[i] == candidates[i-1]:continue

            sums+=candidates[i]
            self.path.append(candidates[i])
            # i+1表明一个数字只能使用一次，这样下次递归的循环就从i+1开始了。
            # i，表明重复的元素可以重复选取。
            self.dfs(candidates,target,sums,i+1) # 再向下一层
            sums-=candidates[i]
            self.path.pop()
```

## [46. 全排列](https://leetcode-cn.com/problems/permutations/)middle

> 排列问题，无start_index，因为没有start_index，所以需要used数组用来标记已经选取过的元素，不重复选择。
>
> - 必须要有used，因为没有start_index了，所以不可以在用i>start_index来去重；
> - [解答](https://www.programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%80%9D%E8%B7%AF)同一种字符只能轮流当一次首字母；
> - dfs出口是len(path)==len(nums)；
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def permuteUnique(self, nums):
        if not nums:return self.res
        nums.sort()
        used = [0]*len(nums)
        self.dfs(nums,used)
        return self.res

    def dfs(self,nums,used):
        # 定义出口
        if len(self.path) == len(nums):
            self.res.append(self.path[:])
            return

        for i in range(len(nums)):
            # 如果树层里重复取值，跳过
            #      // used[i - 1] == 1，说明同⼀树⽀nums[i - 1]使⽤过
            #      // used[i - 1] == 0，说明同⼀树层nums[i - 1]使⽤过
            #      // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
            if i>0 and nums[i]==nums[i-1] and used[i-1]==0:  # i>0对len(nums)==1的很重要
                continue

            # 剪枝(如果当前的元素已经被用过，continue)
            # 排列问题特有的部分，因为没有start_index来标记元素是否访问
            if used[i]==1:
                continue

            self.path.append(nums[i])
            used[i] = 1
            # 树枝递归
            self.dfs(nums,used)
            self.path.pop() # 回溯
            used[i] = 0 # 回溯
```

## [78. 子集](https://leetcode-cn.com/problems/subsets/)middle

> 子集问题，有start_index，利用i>start_index去重；
>
> dfs出口：start_index>=len(nums)；
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> ```

```python
class Solution(object):
    def __init__(self):
        self.res = []
        self.path = []

    def subsetsWithDup(self, nums):
        if not nums:return self.res
        nums.sort()
        # 方法一：
        self.dfs(nums,0)
        return self.res

    def dfs(self,nums,start_index):
        self.res.append(self.path[:])
        # 定义出口
        if start_index>=len(nums):
            return

        for i in range(start_index, len(nums)):
            # i是控制树层，取过的元素不再重复取，避免重复解
            if i>start_index and nums[i]==nums[i-1]:
                continue
            self.path.append(nums[i])
            self.dfs(nums,i+1) # i+1,取过的元素不能重复取
            self.path.pop()
```

## [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)middle

> DFS，模板题。找一个单词是否在二维数据中。记得回溯。

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        m,n=len(board),len(board[0])
        for i in range(m):
            for j in range(n):
                if self.dfs(board,i,j,word,0):
                    return True
        return False
            
    def dfs(self,board,x,y,word,u):
        # u位于word的第几位
        if word[u]!=board[x][y]:return False # 当前字母不对
        if u==len(word)-1:return True # word都匹配完了

        tmp = board[x][y]
        board[x][y]='*'
        dx=[1,0,-1,0]
        dy=[0,1,0,-1]
        for i in range(4):
            a=x+dx[i]
            b=y+dy[i]
            if a>=0 and a<len(board) and b>=0 and b<len(board[0]) and board[a][b]!='*':
                if self.dfs(board,a,b,word,u+1):
                    return True
        board[x][y]=tmp # 回溯
        return False
```

## [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)middle

> 求连通图的数量，DFS。
>
> 全局遍历count遇到1++，遇到1以后dfs，将1能扩散到的位置全部设置为0。

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        # 求连通图的数量？
        if not grid:return 0
        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]=='1':
                    count+=1
                    self.dfs(grid,i,j)
        return count

    def dfs(self,grid,x,y):
        grid[x][y] = '0' # 将访问过的1都换为0
        dx=[0,1,0,-1]
        dy=[1,0,-1,0]
        for i in range(4):
            a = x+dx[i]
            b = y+dy[i]
            if a>=0 and a<len(grid) and b>=0 and b<len(grid[0]) and grid[a][b]=='1':
                self.dfs(grid,a,b)
        # return
```

扩展，求岛屿的最大面积

```python
class Solution:
    def maxAreaOfIsland(self, grid): #List[List[int]]) -> int:
        if not len(grid) or not len(grid[0]):return 0
        max_area = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    area = self.dfs(grid, i, j)
                    max_area = max(max_area, area)
        return max_area

    def dfs(self, grid, x, y):
        area = 1 # 只要进dfs，面积就是1
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        grid[x][y] = 0 # 沉岛思想
        for d in range(4):
            a = x+dx[d]
            b = y+dy[d]
            if a>=0 and a<len(grid) and b>=0 and b<len(grid[0]) and grid[a][b]==1:
                area += self.dfs(grid, a, b)
        return area
```

## [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)middle

> 拓扑排序，BFS。
>
> 图中有环为False，无环为True。
>
> 1、统计每个节点的入度（入度数组）；
>
> 2、统计每个节点的后继节点，有向图能连出去的点（邻接矩阵）；
>
> 3、BFS遍历，入度为0的节点开始，遍历该节点的后继节点，更新入度数组；将入度为0的节点更新进queue；

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites): #: List[List[int]]) -> bool:
        # 1、邻接表：通过结点的索引，我们能够得到这个结点的后继结点；
        # 2、入度数组：通过结点的索引，我们能够得到指向这个结点的结点个数。
        indegrees = [0 for _ in range(numCourses)] # 入度表
        adjacency = [[] for _ in range(numCourses)] # 邻接表, 用于建图
        # 建表 # Get the indegree and adjacency of every course.
        for cur, pre in prerequisites:
            # print(cur, pre) # 打印当前课程，与当前课程的前驱
            indegrees[cur]+=1 # 当前课程入度+1
            adjacency[pre].append(cur) # 那么前驱节点的邻接矩阵中有‘当前节点’
        # // [1, 2] = 2 -> 1
        # // from = item[1] = 2
        # // to = item[0] = 1
        queue = []
        # 找到起始节点，即入度为0的节点 # Get all the courses with the indegree of 0.
        # 获取所有入度为0的课程
        for i in range(numCourses): # i刚好能和课程对上是题目保证的 `必须选修 numCourses 门课程，记为 0 到 numCourses - 1`
            if indegrees[i]==0: # 如果课程i的入度是0
                queue.append(i)
        # BFS
        while queue:
            pre = queue.pop(0)
            # 学完一个前置课程，课程数-1
            numCourses -= 1
            for next_course in adjacency[pre]:
                indegrees[next_course] -= 1
                if indegrees[next_course] == 0:
                    queue.append(next_course)
        # 若课程安排图中存在环，一定有节点的入度始终不为 0
        # 拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排
        return numCourses == 0
```

## [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)middle

> BFS，需要visited
>
> 题目：给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。
>
> ```
> 每一次是原数字减去了一个平方数，直到出现第一个0，此时走过的层数就是最小数量，即为答案。
> # 假设数字为7，就是下面这个树，可以等价最短路径(7-1^2,7-2^2)，7=1+4+1+1
>         7
>        / \
>       6   3
>      / \    \
>     5   2    2
>   / \   \    \
> 1    4   1    1
> ```
>
> 类似与二叉树的层次遍历。
>
> 1、计算好<n的所有平方和。

```python
    def numSquares(self, n):
        # python开根号 num_sqrt = n**0.5
        # 对图中所有的点进行预处理，全都没被访问过，设置为false.
        nums = [i * i for i in range(1, int(n ** 0.5) + 1)]

        visited = set()
        queue=[n] # 起始点
        step=1
        while queue:
            # 求当前层有多少个元素
            for _ in range(len(queue)):
                x = queue.pop(0)
                for sq in nums:
                    tmp=x-sq
                    if tmp==0:return step
                    if tmp not in visited:
                        queue.append(tmp)
                        visited.add(tmp)
            step+=1
        return step
```

## [301. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)hard

# 【栈和队列】

## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)easy

> 遇到左括号入栈，遇到匹配的右括号弹栈，最后判断栈是否为空。

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stk = []
        n = len(s)
        if n%2==1:return False
        for i in range(n):
            if s[i]=='}' and stk and stk[-1]=='{':
                stk.pop()

            elif s[i]==')' and stk and stk[-1]=='(':
                stk.pop()

            elif s[i]==']' and stk and stk[-1]=='[':
                stk.pop()
            else:
                stk.append(s[i])

        # print(stk)
        return False if stk else True
```

## [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)middle

> 栈，入栈格式（上一次str，当前字符的倍数）。
>
> 遇到`[`入栈（倍数、strtmp记得清零），遇到`]`弹栈，遇到数字计算数字，遇到字符统计str。

```python
class Solution:
        # 【核心思想】
        # 碰到[,"数字和当前字符串"入栈，入栈后清空上次的缓存
        # 碰到],"数字和字符串"出栈
        # 栈 index=0: [之前的倍数
        # 栈 index=1: [之前的临时结果
    def decodeString(self, s: str) -> str:
        stk = [] # [倍数，上次str的结果]
        multi = 0
        res = ""
        for ch in s:
            if ch=='[': # 入栈
                stk.append([multi,res])
                multi,res=0,"" # 恢复，开始一轮
            elif ch==']': # 出栈
                curmulti,prestr = stk.pop()
                res = prestr+curmulti*res
                # multi=0
            elif '0'<=ch<='9':
                multi = multi*10+int(ch)
            else: # 当时字符的时候
                res+=ch
        return res
```

# 【模拟】

## [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)middle

> 1）先以左上-右下对角条线为轴做翻转；
> 2）再以中心的竖线为轴做翻转；

```python
class Solution:
    def rotate(self, matrix):
        n = len(matrix)
        # 1.先沿斜对角线翻转
        for i in range(n):
            for j in range(i):
                matrix[i][j],matrix[j][i]=matrix[j][i],matrix[i][j]
        # print(matrix)
        # 2.再沿垂直竖线翻转
#       for(int i = 0;i < n; i++)
#           for(int j = 0, k = n - 1; j < k ; j++, k--) //类似于双指针，由两端向中心靠齐
#               swap(matrix[i][j],matrix[i][k]);
        for i in range(n):
            for j in range(n//2):
                matrix[i][j],matrix[i][n-1-j] = matrix[i][n-1-j],matrix[i][j]

        return matrix
```

# 【贪心】

## [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)middle

> 每次取最大的跳跃步数，当前位置能去的最远的地方`i+nums[i]`，这个就是可以跳跃的覆盖范围。

```python
class Solution(object):
    """
    1、i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。
    2、而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。
    3、如果cover >= 了终点下标，直接return true就可以了。
    """
    def canJump(self, nums):
        cover = 0
        if len(nums) <= 1:return True # 只有一个元素，就是能达到
        i = 0  # python不支持动态修改for循环中变量,使用while循环代替
        while i<= cover: # cover一直在变化
            cover = max(i+nums[i], cover) # i+nums[i] 当前位置最远能去的地方
            if cover>=len(nums)-1: return True
            i += 1
        return False
```

pdd1面

## 253.会议室2middle

> 求所需最小会议室数量。list发生重叠数量就+1。
>
> ```
> # 如果开始时间"<"结束时间：则需增加会议室，同时添加当前结束时间到结束时间列表
> # 如果开始时间">="结束时间：则不需增加，但是需要将之前的最早结束时间替换为当前会议的结束时间
> # 因为每次都要找最早结束时间，所以我们用优先队列来存储结束时间列表。
> ```

```python
import heapq
class Solution:
    def minMeetingRooms(self, intervals): #List[List[int]]) -> int:
        intervals.sort()
        n=len(intervals)
        # end_time是小顶堆，pop()弹出的就是最小值。
        end_time=[intervals[0][1]] # 结束时间
        count=1
        for i in range(1,n):
            # 开始时间<结束时间
            # 发生重叠了，需要多一间房子
            if intervals[i][0]<end_time[0]:# 会议开始时间比最早结束的还要早，需增加会议室
                count+=1
                heapq.heappush(end_time,intervals[i][1]) # 将该会议室的结束时间添加进入小顶堆
            else:# 可以在最早结束的会议之后开始当前会议，之前的最早结束时间变成当前会议结束的时间
                # 一定要先将当前的最小元素弹出
                heapq.heappop(end_time)
                heapq.heappush(end_time,intervals[i][1])
        return count
```

## [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)middle

> 一维降序，二维升序，按第2维插入->同一高度时k值小的排前面。

```python
 # 每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
 # 按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量;
 # 按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。[5,0]vs[5,2]
 #
 # 先按照h维度的身高顺序从高到低排序。确定第一个维度
 # lambda返回的是一个元组：当-x[0](维度h）相同时，再根据x[1]（维度k）从小到大排序
class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x: (-x[0], x[1]))
        print(people) # [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]
        queue = []
        # 根据每个元素的第二个维度k，贪心算法，进行插入
        # people已经排序过了：同一高度时k值小的排前面。
        for p in people:
            queue.insert(p[1], p)
        return queue
```

# 【哈希表】

## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)easy

> 哈希表，hashmap存储，k:targer-num, v:num index。

```python
class Solution(object):
    def twoSum(self, nums, target):
        if len(nums) <= 1:
            return False
        hashmap = {}
        for i in range(len(nums)):
            if nums[i] in hashmap:
                return [hashmap[nums[i]], i]
            else:
                hashmap[target - nums[i]] = i
```

携程实习1面

## [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)middle

> 1. 将不同的字符串转换为字符数组并按照字母顺序进行排序； 
>
> 2. 异位词排序后的结果相同，故可以作为哈希表的key值；
>
> 3. 将字母异位词组成的集合作为哈希表的value值；

```python
class Solution:
    def groupAnagrams(self, strs):
        if not strs or len(strs)==1:return [strs]
        hashmap={}
        for s in strs:
            chars = [x for x in s] # 将字符串转化为字符数组
            chars.sort() # 对字符数组按照字母顺序排序
            key = ''.join(chars)
            if key not in hashmap:
                hashmap[key] = [s]
            else:
                hashmap[key].append(s) # 【attention:这里直接append】
        return list(hashmap.values())
```

## [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)middle

> 每次以x为起点，找x+1,x+2,x+y，res=y-x+1；
>
> 如何确定x? 如果存在x-1则不是起点，如果不存在x-1，那么该点可以成为起始点。 
>
> ```
> 输入：nums = [100,4,200,1,3,2]
> 输出：4
> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
> ```

```python
class Solution:
    # 时间复杂度
    # 1、把数组转换成hashmap 使得查找的速度变成O（1）
    # 2、确保查找序列时是从最小点开始的，如果还有更小点就直接跳过，这也是减少复杂度的重点。
    # 所以，我理解的应该最终复杂度是O(2N)
    def longestConsecutive_hash(self, nums):
        # 每次以x为起点，找x+1,x+2,x+y，res=y-x+1
        # 如何确定x? 如果存在x-1则不是起点，如果不存在x-1，那么该点可以成为起始点。
        hashmap = {}
        # for i in range(len(nums)):
        #     hashmap[nums[i]] = i
        for x in nums:hashmap[x] = x
        res = 0
        for x in hashmap:
            # if not hashmap.get(x-1,0):
            # 如果x-1不存在，说明x可以当做起始点
            if (x-1) not in hashmap:
                y = x # 以当前数x向后枚举
                while (y+1) in hashmap: # 如果x+1存在，y++
                    y+=1
                res = max(res, y-x+1) # 更新答案
        return res
```

## [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)easy

> 哈希表，哈希function: nums[i]=i+1。

```python
class Solution:
    def findDisappearedNumbers(self, nums): #List[int]) -> List[int]:
        n = len(nums)
        for i in range(n):
            # 要过去的下标 num[i]-1
            # nums[下标]=下标+1
            while nums[i]!=i+1 and nums[nums[i]-1]!=nums[i]:
                # 交换
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] # 左边的会比右边的先赋值

        res = []
        # print(nums)
        for i in range(n):
            # print(i)
            if i+1!=nums[i]:
               res.append(i+1)
        return res
```

## [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)middle

> 前缀和。
>
> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。
>
> 思想类似与LC1，维护hashmap，key是该值，value是该值出现的次数。
>
> 题目等价于求满足`presum[j]-presum[i-1]=k`的数量。维护遍历当前值presum[j]，求presum[j]-k对应的个数。

```python
# 前缀和 + 哈希表优化，时间复杂度O(N)
# key: 前缀和
# value: key 对应的前缀和的个数
def subarraySum(self, nums, k):
    hash_map = {}
    hash_map[0] = 1 # 前缀和为0的数量有1个。默认nums[-1]=0
    res = 0
    sums = 0 # 前缀和
    for x in nums:
        sums += x
        # print(sums) # 1,2,3
        # 问自己！当前前缀和（sums）-k，之前出现过吗？如果出现过了记作a，那么sums-a=k，count++
        # (a,b)=presum[b]-presum[a]=k
        # presum[b]=sums
        # 求a出现过几次
        res += hash_map.get(sums-k, 0) # hash_map[sums-k] KeyError: -1
        # 维护hashmap的定义
        hash_map[sums] = hash_map.get(sums, 0) + 1 # 计算前缀和为sums的个数

    # print(hash_map) # {0: 1, 1: 1, 2: 1, 3: 1}
    return res
```

# 【二进制】

## [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)easy

> 二进制。**异或！相同为0，不相同为1。**
>
> 给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # // 异或满足两条定律：
        # // 1、a^b = b^a
        # // 2、a^a=0
        # // 3、a^0=a;
        res = 0
        for x in nums:
            res^=x
        return res
```

## [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)easy

> 这两个数字对应二进制位不同的位置的数目。
>
> 先异或，再统计1。

```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x^y).count('1')
```

# 【其他】

## [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)easy

> 摩尔投票法，时间复杂度O(n)。
>
> 返回在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

```python
# 从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个
class Solution:
    def majorityElement(self, nums): #List[int]) -> int:
        cand_num,count=nums[0],1
        for i in range(1,len(nums)):
            if nums[i]==cand_num:
                count+=1
            else:
                count-=1
                if count==0:
                    cand_num=nums[i]
                    count=1
        return cand_num
```

## [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

>一次建树，多次查询。
>
>tree = tree[a]的解释：lookup的key是字符，value是另一个字典，每一个字典就相当于树的节点，tree=tree[a]相当于把指针移到下一个字符所在的节点。

```python
class Node:
    # isWord 表示从根节点到当前节点为止，该路径是否形成了一个有效的字符串。
    # children 是该节点的所有子节点。
    def __init__(self):
        self.isword=False
        self.children=collections.defaultdict(Node) # {字符：Node}

class Trie:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = Node()

    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self.root
        for w in word:
            cur = cur.children[w] # 移到下个字符的位置
        cur.isword = True

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        # 断了、没找到、找到了
        cur = self.root
        for w in word:
            cur = cur.children.get(w)
            if cur == None:
                return False
        return cur.isword

    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        cur = self.root
        for w in prefix:
            cur = cur.children.get(w)
            if cur == None:
                return False
        return True
```

# 【未做】

[399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)

[621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)